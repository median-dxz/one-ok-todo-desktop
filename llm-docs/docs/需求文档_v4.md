# One Ok Todo 需求文档 v4.0

## 1. 应用定位与核心价值

### 1.1 应用定位

单人使用的时间线型任务管理工具，以"时间线思维"组织任务，而非传统的列表或看板模式。

### 1.2 核心特性

- **时间线优先**: 任务以时间线（Timeline）为组织单位，体现事件的顺序性
- **多维依赖关系**: 支持节点间依赖、跨 Timeline 依赖、多分支依赖
- **灵活循环任务**: 支持多种循环模式、任务轮换、定时/定量执行
- **备忘条功能**: 可视化 YAML 编辑器，支持条目切换类型与同级排序
- **多端同步**: 通过 WebDAV 实现数据同步

---

## 2. 数据模型定义

### 2.1 核心实体关系

```text
RootData (根对象)
  └── TimelineGroup[] (时间线分组)
        └── Timeline[] (时间线)
              ├── Node[] (节点)
              │     ├── TaskNode (普通任务节点)
              │     └── GroupNode (并列任务组)
              │           └── SubTask[] (组内子任务)
              ├── Dependency[] (依赖关系)
              │     ├── normal (节点间依赖)
              │     ├── split (fork 派生依赖 - 支持多分支)
              │     └── timeline (跨时间线依赖 - 支持多依赖)
              └── RecurrenceConfig? (循环任务配置)
                    ├── 循环类型 (daily/weekly/monthly)
                    ├── 时间参数 (星期/日期/时长分摊)
                    ├── 任务轮换 (ABCABC...)
                    └── 统计信息 (完成次数等)
```

### 2.2 类型定义

#### 2.2.1 节点状态

```typescript
type NodeStatus = 'todo' | 'doing' | 'done' | 'skipped' | 'lock';
```

| 状态      | 说明   | 业务规则                                | 触发条件         |
| --------- | ------ | --------------------------------------- | ---------------- |
| `todo`    | 待办   | 默认初始状态                            | 节点创建时       |
| `doing`   | 进行中 | **自动计算**：有子任务/依赖项处于 doing | **系统自动设置** |
| `done`    | 已完成 | **自动计算**：所有子任务完成            | **系统自动设置** |
| `skipped` | 已跳过 | 用于循环任务中跳过本次执行              | 用户手动设置     |
| `lock`    | 已锁定 | 等待前置条件满足，不可手动操作          | **系统自动计算** |

**状态计算规则**:

- `doing`: 当节点有任一子任务/依赖项处于 doing 状态时
- `done`: 当节点所有子任务都完成（或 skipped）时
- **done → doing 的撤销限制**: 仅当后继节点都不是 done 状态时才允许撤销

#### 2.2.2 任务执行模式

```typescript
type TaskMode = 'scheduled' | 'quantitative';

interface TaskModeConfig {
  mode: TaskMode;
  // 定时模式配置
  scheduledConfig?: {
    deadline?: string; // ISO 8601 格式
    reminder?: string; // 提醒时间
  };
  // 定量模式配置
  quantitativeConfig?: {
    target: number; // 目标数量
    current: number; // 当前完成数量
    unit?: string; // 单位（如"次"、"个"、"小时"）
  };
}
```

**执行模式说明**:

- `scheduled`: 定时模式，任务到达指定时间后可执行
- `quantitative`: 定量模式，需要完成指定数量才算完成

#### 2.2.3 依赖关系

```typescript
interface Dependency {
  id: string; // 依赖关系唯一标识
  type: 'normal' | 'split' | 'timeline';
  from: string | string[]; // ← 支持数组：多源依赖
  to: string | string[]; // ← 支持数组：多目标依赖
  description?: string; // 可选的依赖说明
}
```

**依赖类型说明**:
| 类型 | from | to | 说明 | 使用场景 |
|------|------|----|----- |----------|
| `normal` | Node ID | Node ID | 节点 A 必须在节点 B 之前完成 | 同一 Timeline 内的任务顺序 |
| `split` | Node ID | **Timeline ID[]** | 从节点 A fork 出**多个**新的 Timeline | **多分支任务** |
| `timeline` | **Timeline ID[]** | Node ID | 节点等待**多个** Timeline 完成 | **跨 Timeline 的依赖关系** |

**多依赖示例**:

```yaml
dependencies:
  # 单节点依赖多个 Timeline
  - id: 'dep-multi-tl'
    type: 'timeline'
    from: ['visa-timeline', 'insurance-timeline'] # 多个前置 Timeline
    to: 'book-flight-node'
    description: '签证和保险都办好才能订机票'

  # 单节点 fork 出多个 Timeline
  - id: 'dep-multi-split'
    type: 'split'
    from: 'project-start-node'
    to: ['frontend-tl', 'backend-tl', 'design-tl'] # 派生多个分支
```

#### 2.2.4 节点类型

```typescript
// 基础节点属性
interface BaseNode {
  id: string; // 全局唯一标识
  title: string; // 节点标题
  status: NodeStatus; // 节点状态（自动计算）
  mode?: TaskModeConfig; // 任务执行模式
  depends_on?: string[]; // 依赖的节点 ID 列表
  depends_on_timeline?: string[]; // 依赖的 Timeline ID 列表
}

// 普通任务节点
interface TaskNode extends BaseNode {
  type: 'task';
}

// 并列任务组
interface GroupNode extends BaseNode {
  type: 'group';
  subtasks: SubTask[]; // 组内子任务（扁平结构，不支持嵌套）
}

// 子任务（仅存在于 GroupNode 中）
interface SubTask {
  id: string;
  title: string;
  status: NodeStatus; // 也支持自动计算
  mode?: TaskModeConfig; // SubTask 也支持执行模式
  // 注意: SubTask 不支持 depends_on 和 depends_on_timeline 字段
}

type Node = TaskNode | GroupNode;
```

#### 2.2.5 循环任务配置

```typescript
type RecurrenceFrequency = 'daily' | 'weekly' | 'monthly';

interface WeeklyConfig {
  // 选定星期（0-6，0表示周日）
  weekdays: number[]; // 例如 [1, 3, 5] 表示周一、三、五
  // 总时长分摊到每周
  totalDuration?: number; // 单位：小时
  durationPerWeek?: number; // 自动计算或手动设置
}

interface MonthlyConfig {
  // 选定日期（1-31）
  days: number[]; // 例如 [1, 15] 表示每月1号和15号
}

interface RecurrencePattern {
  // 任务序列（支持多任务轮换）
  tasks: string[]; // 任务标题数组，例如 ["A", "B", "C"]
  // 当前轮换位置
  currentIndex?: number; // 默认 0
}

interface RecurrenceStats {
  totalCompleted: number; // 总完成次数
  totalSkipped: number; // 总跳过次数
  lastCompleted?: string; // 最后完成时间（ISO 8601）
  lastSkipped?: string; // 最后跳过时间
  // 按任务统计（当有多任务轮换时）
  byTask?: Record<
    string,
    {
      completed: number;
      skipped: number;
    }
  >;
}

interface RecurrenceConfig {
  frequency: RecurrenceFrequency;

  // 时间参数（根据 frequency 选择）
  weeklyConfig?: WeeklyConfig;
  monthlyConfig?: MonthlyConfig;

  // 任务轮换
  pattern?: RecurrencePattern;

  // 统计信息
  stats: RecurrenceStats;

  // 是否激活
  active: boolean;
}
```

#### 2.2.6 时间线结构

```typescript
interface Timeline {
  id: string; // 时间线唯一标识
  title: string; // 时间线标题
  nodes: Node[]; // 节点列表（按执行顺序排列）
  dependencies?: Dependency[]; // 依赖关系列表

  // 循环任务配置
  recurrence?: RecurrenceConfig; // 如果存在则为循环任务

  status?: 'todo' | 'doing' | 'done'; // Timeline 整体状态（自动计算）
}
```

**循环任务特性**:

- **不包含 nodes 数组**: 循环任务的节点由时间计算生成，不持久化存储
- **统计信息**: 记录总完成次数、跳过次数等
- **任务轮换**: 支持 ABCABC 模式，每次循环使用不同的任务
- **时间生成逻辑**: 根据 `recurrence.frequency` 和时间参数自动计算当前周期的任务实例

**循环任务示例**:

```yaml
timelines:
  - id: 'morning-routine'
    title: '晨间例行'
    # 注意：循环任务没有 nodes 字段
    recurrence:
      frequency: 'daily'
      pattern:
        tasks: ['冥想', '阅读', '写日记']
        currentIndex: 0
      stats:
        totalCompleted: 45
        totalSkipped: 3
        byTask:
          '冥想': { completed: 15, skipped: 1 }
          '阅读': { completed: 15, skipped: 1 }
          '写日记': { completed: 15, skipped: 1 }
      active: true
    status: 'todo'

  - id: 'weekly-review'
    title: '周回顾'
    recurrence:
      frequency: 'weekly'
      weeklyConfig:
        weekdays: [0] # 每周日
      pattern:
        tasks: ['工作回顾', '生活回顾']
      stats:
        totalCompleted: 8
        totalSkipped: 0
      active: true
```

#### 2.2.7 时间线分组

```typescript
interface TimelineGroup {
  id: string; // 分组唯一标识
  title: string; // 分组标题
  timelines: Timeline[]; // 该分组下的所有时间线
}
```

#### 2.2.8 根数据结构

```typescript
interface RootData {
  version: string; // 数据模型版本（用于未来迁移）
  groups: TimelineGroup[]; // 所有时间线分组
  metadata?: {
    // 元数据
    lastModified: string; // ISO 8601 格式
    syncStatus?: 'synced' | 'pending' | 'error';
  };
}
```

---

## 3. 业务规则定义

### 3.1 节点状态自动计算

#### 3.1.1 doing 状态计算

```typescript
function computeDoingStatus(node: Node, timeline: Timeline): boolean {
  if (node.type === 'group') {
    // GroupNode: 任一 subtask 为 doing 则为 doing
    return node.subtasks.some((st) => st.status === 'doing');
  }

  // TaskNode: 检查是否有依赖项处于 doing
  if (node.depends_on && node.depends_on.length > 0) {
    return node.depends_on.some((depId) => {
      const depNode = timeline.nodes.find((n) => n.id === depId);
      return depNode && depNode.status === 'doing';
    });
  }

  return false;
}
```

#### 3.1.2 done 状态计算

```typescript
function computeDoneStatus(node: Node): boolean {
  if (node.type === 'group') {
    // GroupNode: 所有 subtask 都 done 或 skipped
    return node.subtasks.every((st) => st.status === 'done' || st.status === 'skipped');
  }

  // TaskNode: 检查定量模式完成度
  if (node.mode?.mode === 'quantitative') {
    const config = node.mode.quantitativeConfig!;
    return config.current >= config.target;
  }

  // 其他情况由用户标记或手动触发
  return node.status === 'done';
}
```

#### 3.1.3 done → doing 撤销规则

```typescript
function canRevertDoneToDoing(nodeId: string, timeline: Timeline): boolean {
  // 查找所有依赖该节点的后继节点
  const successors = timeline.nodes.filter((n) => n.depends_on?.includes(nodeId));

  // 只有当所有后继节点都不是 done 时才允许撤销
  return successors.every((n) => n.status !== 'done');
}
```

### 3.2 lock 状态自动计算

```typescript
function computeNodeLockStatus(node: BaseNode, timeline: Timeline, allTimelines: Timeline[]): boolean {
  // 1. 检查节点依赖
  if (node.depends_on && node.depends_on.length > 0) {
    const hasUnfinishedNodeDeps = node.depends_on.some((depNodeId) => {
      const depNode = timeline.nodes.find((n) => n.id === depNodeId);
      return depNode && depNode.status !== 'done' && depNode.status !== 'skipped';
    });
    if (hasUnfinishedNodeDeps) return true;
  }

  // 2. 检查 Timeline 依赖（支持多依赖）
  if (node.depends_on_timeline && node.depends_on_timeline.length > 0) {
    const hasUnfinishedTimelineDeps = node.depends_on_timeline.some((timelineId) => {
      const depTimeline = allTimelines.find((tl) => tl.id === timelineId);
      return depTimeline && computeTimelineStatus(depTimeline) !== 'done';
    });
    if (hasUnfinishedTimelineDeps) return true;
  }

  return false;
}
```

### 3.3 Timeline 状态计算

```typescript
function computeTimelineStatus(timeline: Timeline): 'todo' | 'doing' | 'done' {
  // 循环任务没有 nodes，状态基于统计信息
  if (timeline.recurrence) {
    return timeline.status || 'todo';
  }

  const nodes = timeline.nodes;
  if (nodes.every((n) => n.status === 'done' || n.status === 'skipped')) {
    return 'done';
  }
  if (nodes.some((n) => n.status === 'doing')) {
    return 'doing';
  }
  return 'todo';
}
```

### 3.4 循环任务实例生成

```typescript
interface RecurrenceInstance {
  id: string; // 实例唯一标识
  timelineId: string; // 所属循环 Timeline
  taskTitle: string; // 当前任务标题（来自 pattern）
  scheduledDate: string; // 计划执行日期（ISO 8601）
  status: NodeStatus; // 实例状态
  completedDate?: string; // 完成日期
}

function generateRecurrenceInstances(timeline: Timeline, startDate: Date, endDate: Date): RecurrenceInstance[] {
  if (!timeline.recurrence || !timeline.recurrence.active) return [];

  const instances: RecurrenceInstance[] = [];
  const { frequency, pattern, weeklyConfig, monthlyConfig } = timeline.recurrence;

  let current = new Date(startDate);
  let patternIndex = pattern?.currentIndex || 0;

  while (current <= endDate) {
    let shouldGenerate = false;

    switch (frequency) {
      case 'daily':
        shouldGenerate = true;
        break;
      case 'weekly':
        if (weeklyConfig) {
          const weekday = current.getDay();
          shouldGenerate = weeklyConfig.weekdays.includes(weekday);
        }
        break;
      case 'monthly':
        if (monthlyConfig) {
          const day = current.getDate();
          shouldGenerate = monthlyConfig.days.includes(day);
        }
        break;
    }

    if (shouldGenerate) {
      const taskTitle = pattern?.tasks[patternIndex % pattern.tasks.length] || timeline.title;

      instances.push({
        id: `${timeline.id}-${current.toISOString()}`,
        timelineId: timeline.id,
        taskTitle,
        scheduledDate: current.toISOString(),
        status: 'todo',
      });

      patternIndex++;
    }

    // 移动到下一天
    current.setDate(current.getDate() + 1);
  }

  return instances;
}
```

### 3.5 GroupNode 规则

| 规则       | 说明                                              | 强制性  |
| ---------- | ------------------------------------------------- | ------- |
| 不可嵌套   | subtasks 中的节点不能是 GroupNode                 | ✅ 强制 |
| 状态计算   | GroupNode.status 由 subtasks 计算得出             | ✅ 强制 |
| 无依赖关系 | subtasks 不支持 depends_on 和 depends_on_timeline | ✅ 强制 |

**GroupNode 状态计算逻辑**:

```typescript
function computeGroupStatus(subtasks: SubTask[]): NodeStatus {
  // 检查所有 subtask 状态
  if (subtasks.every((t) => t.status === 'done')) return 'done';
  if (subtasks.every((t) => t.status === 'skipped')) return 'skipped';
  if (subtasks.some((t) => t.status === 'doing')) return 'doing';
  return 'todo';
}
```

---

## 4. 核心操作定义

### 4.1 节点操作

#### 4.1.1 新增节点

```typescript
interface AddNodeParams {
  timelineId: string;
  node: Omit<Node, 'id' | 'status'>; // status 由系统计算
  position?: 'start' | 'end' | number;
  dependsOn?: string[];
  dependsOnTimeline?: string[];
  mode?: TaskModeConfig;
}

function addNode(params: AddNodeParams): string {
  const newNode = {
    ...params.node,
    id: generateId(),
    status: 'todo', // 初始状态
    depends_on: params.dependsOn,
    depends_on_timeline: params.dependsOnTimeline,
    mode: params.mode,
  };

  // 添加节点到 Timeline
  addToTimeline(params.timelineId, newNode, params.position);

  // 自动计算 lock 状态
  updateNodeStatus(newNode);

  return newNode.id;
}
```

#### 4.1.2 删除节点

```typescript
interface RemoveNodeParams {
  timelineId: string;
  nodeId: string;
}

function removeNode(params: RemoveNodeParams): void {
  const timeline = findTimeline(params.timelineId);
  const node = findNode(params.timelineId, params.nodeId);

  // 前置条件检查
  if (node.status === 'lock') {
    throw new Error('节点处于锁定状态，不能删除');
  }

  if (timeline.recurrence) {
    throw new Error('循环任务节点不能删除，只能跳过');
  }

  // 后置条件
  // 1. 从 Timeline.nodes 移除节点
  removeFromTimeline(params.timelineId, params.nodeId);

  // 2. 从 Timeline.dependencies 移除所有涉及该节点的依赖关系
  removeDependenciesForNode(params.timelineId, params.nodeId);

  // 3. 触发相关节点的 lock 状态重新计算
  triggerDependentNodesUpdate(params.timelineId, params.nodeId);
}
```

#### 4.1.3 编辑节点

```typescript
interface UpdateNodeParams {
  timelineId: string;
  nodeId: string;
  updates: Partial<Omit<Node, 'id' | 'type' | 'status'>>; // 不允许直接修改 status
}

function updateNode(params: UpdateNodeParams): void {
  const node = findNode(params.timelineId, params.nodeId);

  if (node.status === 'lock') {
    throw new Error('节点处于锁定状态，不能编辑');
  }

  Object.assign(node, params.updates);

  // 如修改了依赖关系，触发 lock 状态重新计算
  if (params.updates.depends_on || params.updates.depends_on_timeline) {
    updateNodeLockStatus(params.timelineId, params.nodeId);
  }
}
```

#### 4.1.4 更新节点完成进度（定量模式）

```typescript
interface UpdateNodeProgressParams {
  timelineId: string;
  nodeId: string;
  progress: number; // 增加的进度值
}

function updateNodeProgress(params: UpdateNodeProgressParams): void {
  const node = findNode(params.timelineId, params.nodeId);

  if (node.mode?.mode !== 'quantitative') {
    throw new Error('节点不是定量模式');
  }

  const config = node.mode.quantitativeConfig!;
  config.current = Math.min(config.current + params.progress, config.target);

  // 自动计算 done 状态
  if (config.current >= config.target) {
    node.status = 'done';
  }

  // 触发相关节点状态更新
  triggerDependentNodesUpdate(params.timelineId, params.nodeId);
}
```

#### 4.1.5 撤销节点完成状态

```typescript
interface RevertNodeTodoParams {
  timelineId: string;
  nodeId: string;
}

function revertNodeToDoing(params: RevertNodeTodoParams): void {
  const timeline = findTimeline(params.timelineId);
  const node = findNode(params.timelineId, params.nodeId);

  // 检查是否允许撤销
  if (!canRevertDoneToDoing(params.nodeId, timeline)) {
    throw new Error('不能撤销：后继节点已完成');
  }

  // 撤销状态
  if (node.mode?.mode === 'quantitative') {
    // 定量模式：重置进度
    node.mode.quantitativeConfig!.current = 0;
  }

  node.status = 'doing';

  // 触发相关节点状态更新
  triggerDependentNodesUpdate(params.timelineId, params.nodeId);
}
```

#### 4.1.6 移动节点

```typescript
interface MoveNodeParams {
  timelineId: string;
  nodeId: string;
  toPosition: number; // 目标位置索引
}

function moveNode(params: MoveNodeParams): void {
  const node = findNode(params.timelineId, params.nodeId);

  if (node.status === 'lock') {
    throw new Error('节点处于锁定状态，不能移动');
  }

  // 调整 Timeline.nodes 中的节点顺序
  reorderNode(params.timelineId, params.nodeId, params.toPosition);

  // 依赖关系保持不变
}
```

### 4.2 高级操作

#### 4.2.1 Revert 节点（任务回滚）

```typescript
interface RevertNodeParams {
  timelineId: string;
  fromNodeId: string; // 源节点 ID（通常是已完成的节点）
}

function revertNode(params: RevertNodeParams): string {
  const sourceNode = findNode(params.timelineId, params.fromNodeId);

  // 业务逻辑
  const newNode = {
    id: generateId(),
    type: sourceNode.type,
    title: sourceNode.title,
    status: 'todo' as NodeStatus,
    // 清空 depends_on 字段（新节点为独立节点）
    depends_on: undefined,
    // 保留 depends_on_timeline 字段（Timeline 依赖仍然有效）
    depends_on_timeline: sourceNode.depends_on_timeline,
    mode: sourceNode.mode,
  };

  // 添加到 Timeline.nodes 末尾
  addToTimeline(params.timelineId, newNode, 'end');

  // 触发 lock 状态计算
  updateNodeLockStatus(params.timelineId, newNode.id);

  return newNode.id;
}
```

#### 4.2.2 Fork 时间线（任务分支）

```typescript
interface ForkTimelineParams {
  fromNodeId: string; // 源节点 ID
  newTimelineTitle: string; // 新时间线标题
  targetGroupId?: string; // 目标分组 ID（可选，默认与源相同）
}

function forkTimeline(params: ForkTimelineParams): string {
  const sourceNode = findNodeGlobally(params.fromNodeId);
  const sourceTimeline = findTimelineByNode(params.fromNodeId);

  // 1. 创建新的 Timeline
  const newTimeline: Timeline = {
    id: generateId(),
    title: params.newTimelineTitle,
    nodes: [],
    dependencies: [],
    status: 'todo',
  };

  // 2. 复制源节点作为新 Timeline 的第一个节点
  const copiedNode = {
    ...sourceNode,
    id: generateId(),
    status: 'todo' as NodeStatus,
  };
  newTimeline.nodes.push(copiedNode);

  // 3. 在源 Timeline 中创建 split 类型的 Dependency
  const dependency: Dependency = {
    id: generateId(),
    type: 'split',
    from: params.fromNodeId,
    to: newTimeline.id, // 注意: to 字段指向 Timeline ID
  };
  sourceTimeline.dependencies?.push(dependency);

  // 4. 将新 Timeline 添加到目标 TimelineGroup
  const targetGroupId = params.targetGroupId || findGroupByTimeline(sourceTimeline.id);
  addTimelineToGroup(targetGroupId, newTimeline);

  return newTimeline.id;
}
```

#### 4.2.3 多分支 Fork

```typescript
interface ForkMultiTimelinesParams {
  fromNodeId: string;
  newTimelines: Array<{
    title: string;
    targetGroupId?: string;
  }>;
}

function forkMultiTimelines(params: ForkMultiTimelinesParams): string[] {
  const newTimelineIds: string[] = [];

  for (const tlConfig of params.newTimelines) {
    const newTlId = forkTimeline({
      fromNodeId: params.fromNodeId,
      newTimelineTitle: tlConfig.title,
      targetGroupId: tlConfig.targetGroupId,
    });
    newTimelineIds.push(newTlId);
  }

  // 更新为单个 split 依赖（支持多目标）
  const sourceTimeline = findTimelineByNode(params.fromNodeId);

  // 移除之前创建的单个 split 依赖
  sourceTimeline.dependencies = sourceTimeline.dependencies?.filter(
    (d) => !(d.type === 'split' && d.from === params.fromNodeId),
  );

  // 创建多目标 split 依赖
  const dependency: Dependency = {
    id: generateId(),
    type: 'split',
    from: params.fromNodeId,
    to: newTimelineIds, // 数组形式
  };
  sourceTimeline.dependencies?.push(dependency);

  return newTimelineIds;
}
```

### 4.3 Timeline 依赖管理

#### 4.3.1 添加 Timeline 依赖

```typescript
interface AddTimelineDependencyParams {
  fromTimelineId: string; // 前置 Timeline ID
  toNodeId: string; // 依赖该 Timeline 的节点 ID
  toTimelineId: string; // 节点所在的 Timeline ID
  description?: string; // 可选的依赖说明
}

function addTimelineDependency(params: AddTimelineDependencyParams): string {
  // 前置条件检查
  const fromTimeline = findTimeline(params.fromTimelineId);
  const toTimeline = findTimeline(params.toTimelineId);
  const targetNode = findNode(params.toTimelineId, params.toNodeId);

  if (!fromTimeline || !toTimeline || !targetNode) {
    throw new Error('Timeline 或节点不存在');
  }

  // 循环依赖检测
  if (hasCircularTimelineDependency(params.fromTimelineId, params.toTimelineId, getAllTimelines())) {
    throw new Error('不能创建循环依赖');
  }

  // 创建依赖关系
  const dependency: Dependency = {
    id: generateId(),
    type: 'timeline',
    from: params.fromTimelineId,
    to: params.toNodeId,
    description: params.description,
  };

  toTimeline.dependencies = toTimeline.dependencies || [];
  toTimeline.dependencies.push(dependency);

  // 更新节点的 depends_on_timeline
  targetNode.depends_on_timeline = targetNode.depends_on_timeline || [];
  if (!targetNode.depends_on_timeline.includes(params.fromTimelineId)) {
    targetNode.depends_on_timeline.push(params.fromTimelineId);
  }

  // 触发目标节点的 lock 状态计算
  updateNodeLockStatus(params.toTimelineId, params.toNodeId);

  return dependency.id;
}
```

#### 4.3.2 添加多 Timeline 依赖

```typescript
interface AddMultiTimelineDependencyParams {
  fromTimelineIds: string[]; // 多个前置 Timeline
  toNodeId: string;
  toTimelineId: string;
  description?: string;
}

function addMultiTimelineDependency(params: AddMultiTimelineDependencyParams): string {
  const toTimeline = findTimeline(params.toTimelineId);
  const targetNode = findNode(params.toTimelineId, params.toNodeId);

  // 创建依赖关系
  const dependency: Dependency = {
    id: generateId(),
    type: 'timeline',
    from: params.fromTimelineIds, // 数组形式
    to: params.toNodeId,
    description: params.description,
  };

  toTimeline.dependencies = toTimeline.dependencies || [];
  toTimeline.dependencies.push(dependency);

  // 更新节点的 depends_on_timeline
  targetNode.depends_on_timeline = [...(targetNode.depends_on_timeline || []), ...params.fromTimelineIds];

  // 触发 lock 状态计算
  updateNodeLockStatus(params.toTimelineId, params.toNodeId);

  return dependency.id;
}
```

#### 4.3.3 移除 Timeline 依赖

```typescript
interface RemoveTimelineDependencyParams {
  dependencyId: string; // 依赖关系 ID
  timelineId: string; // 包含该依赖的 Timeline ID
}

function removeTimelineDependency(params: RemoveTimelineDependencyParams): void {
  const timeline = findTimeline(params.timelineId);
  const dependency = timeline.dependencies?.find((d) => d.id === params.dependencyId);

  if (!dependency || dependency.type !== 'timeline') {
    throw new Error('依赖关系不存在或类型不匹配');
  }

  // 获取目标节点
  const targetNode = findNode(params.timelineId, dependency.to as string);

  // 从 Timeline.dependencies 移除
  timeline.dependencies = timeline.dependencies?.filter((d) => d.id !== params.dependencyId);

  // 从节点的 depends_on_timeline 移除
  const fromIds = Array.isArray(dependency.from) ? dependency.from : [dependency.from];
  targetNode.depends_on_timeline = targetNode.depends_on_timeline?.filter((tlId) => !fromIds.includes(tlId));

  // 触发 lock 状态重新计算
  updateNodeLockStatus(params.timelineId, dependency.to as string);
}
```

### 4.4 GroupNode 操作

#### 4.4.1 将节点拖入组

```typescript
interface MoveNodeToGroupParams {
  timelineId: string;
  nodeId: string; // 要移入的节点 ID（必须是 TaskNode）
  groupId: string; // 目标 GroupNode ID
}

function moveNodeToGroup(params: MoveNodeToGroupParams): void {
  const node = findNode(params.timelineId, params.nodeId) as TaskNode;
  const group = findNode(params.timelineId, params.groupId) as GroupNode;

  // 前置条件
  if (node.type === 'group') {
    throw new Error('不能将 GroupNode 移入另一个 GroupNode');
  }

  if (node.depends_on && node.depends_on.length > 0) {
    throw new Error('节点有依赖关系，需先解除');
  }

  if (node.depends_on_timeline && node.depends_on_timeline.length > 0) {
    throw new Error('节点有 Timeline 依赖关系，需先解除');
  }

  if (node.status === 'lock') {
    throw new Error('节点处于锁定状态，不能移动');
  }

  // 后置条件
  // 1. 从 Timeline.nodes 移除该节点
  removeFromTimeline(params.timelineId, params.nodeId);

  // 2. 转换为 SubTask 格式（移除所有依赖字段）
  const subtask: SubTask = {
    id: node.id,
    title: node.title,
    status: node.status,
    mode: node.mode,
    // SubTask 不支持任何依赖字段
  };

  // 3. 添加到 GroupNode.subtasks
  group.subtasks.push(subtask);

  // 4. 重新计算 GroupNode.status
  group.status = computeGroupStatus(group.subtasks);
}
```

#### 4.4.2 将节点拖出组

```typescript
interface MoveNodeOutOfGroupParams {
  timelineId: string;
  groupId: string;
  subtaskId: string; // 要移出的 subtask ID
  toPosition?: number; // 移出后在 Timeline.nodes 中的位置
}

function moveNodeOutOfGroup(params: MoveNodeOutOfGroupParams): void {
  const group = findNode(params.timelineId, params.groupId) as GroupNode;
  const subtask = group.subtasks.find((st) => st.id === params.subtaskId);

  if (!subtask) {
    throw new Error('SubTask 不存在');
  }

  if (subtask.status === 'lock') {
    throw new Error('SubTask 处于锁定状态，不能移出');
  }

  // 1. 从 GroupNode.subtasks 移除
  group.subtasks = group.subtasks.filter((st) => st.id !== params.subtaskId);

  // 2. 转换为 TaskNode 格式
  const taskNode: TaskNode = {
    id: subtask.id,
    type: 'task',
    title: subtask.title,
    status: subtask.status,
    mode: subtask.mode,
    // SubTask 没有依赖字段，转换后也不需要添加
  };

  // 3. 插入到 Timeline.nodes 指定位置
  addToTimeline(params.timelineId, taskNode, params.toPosition);

  // 4. 重新计算 GroupNode.status
  group.status = computeGroupStatus(group.subtasks);
}
```

#### 4.4.3 转换为平行时间线

```typescript
interface ConvertGroupToTimelinesParams {
  timelineId: string;
  groupId: string;
  targetGroupId?: string; // 目标分组 ID（可选）
}

function convertGroupToTimelines(params: ConvertGroupToTimelinesParams): string[] {
  const group = findNode(params.timelineId, params.groupId) as GroupNode;
  const newTimelineIds: string[] = [];

  // 1. 为每个 subtask 创建独立的 Timeline
  for (const subtask of group.subtasks) {
    const newTimeline: Timeline = {
      id: generateId(),
      title: subtask.title,
      nodes: [
        {
          id: subtask.id,
          type: 'task',
          title: subtask.title,
          status: subtask.status,
          mode: subtask.mode,
          // SubTask 没有依赖字段
        },
      ],
      dependencies: [],
      status: 'todo',
    };

    const targetGroupId = params.targetGroupId || findGroupByTimeline(params.timelineId);
    addTimelineToGroup(targetGroupId, newTimeline);

    newTimelineIds.push(newTimeline.id);
  }

  // 2. 从原 Timeline 移除该 GroupNode
  removeFromTimeline(params.timelineId, params.groupId);

  return newTimelineIds;
}
```

### 4.5 循环任务操作

#### 4.5.1 创建循环任务

```typescript
interface CreateRecurrenceTimelineParams {
  groupId: string;
  title: string;
  recurrence: RecurrenceConfig;
}

function createRecurrenceTimeline(params: CreateRecurrenceTimelineParams): string {
  const timeline: Timeline = {
    id: generateId(),
    title: params.title,
    nodes: [], // 循环任务不包含 nodes
    recurrence: {
      ...params.recurrence,
      stats: {
        totalCompleted: 0,
        totalSkipped: 0,
      },
      active: true,
    },
    status: 'todo',
  };

  addTimelineToGroup(params.groupId, timeline);

  return timeline.id;
}
```

#### 4.5.2 完成循环任务实例

```typescript
interface CompleteRecurrenceInstanceParams {
  timelineId: string;
  instanceDate: string; // ISO 8601
}

function completeRecurrenceInstance(params: CompleteRecurrenceInstanceParams): void {
  const timeline = findTimeline(params.timelineId);

  if (!timeline.recurrence) {
    throw new Error('不是循环任务');
  }

  const { pattern, stats } = timeline.recurrence;

  // 更新统计信息
  stats.totalCompleted++;
  stats.lastCompleted = new Date().toISOString();

  // 如果有任务轮换，更新对应任务的统计
  if (pattern && pattern.tasks.length > 0) {
    stats.byTask = stats.byTask || {};

    const currentTaskIndex = pattern.currentIndex || 0;
    const taskTitle = pattern.tasks[currentTaskIndex % pattern.tasks.length];

    const taskStats = stats.byTask[taskTitle] || { completed: 0, skipped: 0 };
    taskStats.completed++;
    stats.byTask[taskTitle] = taskStats;

    // 移动到下一个任务
    pattern.currentIndex = (currentTaskIndex + 1) % pattern.tasks.length;
  }

  saveTimeline(timeline);
}
```

#### 4.5.3 跳过循环任务实例

```typescript
interface SkipRecurrenceInstanceParams {
  timelineId: string;
  instanceDate: string;
}

function skipRecurrenceInstance(params: SkipRecurrenceInstanceParams): void {
  const timeline = findTimeline(params.timelineId);

  if (!timeline.recurrence) {
    throw new Error('不是循环任务');
  }

  const { pattern, stats } = timeline.recurrence;

  // 更新统计信息
  stats.totalSkipped++;
  stats.lastSkipped = new Date().toISOString();

  // 更新任务统计
  if (pattern && pattern.tasks.length > 0) {
    stats.byTask = stats.byTask || {};

    const currentTaskIndex = pattern.currentIndex || 0;
    const taskTitle = pattern.tasks[currentTaskIndex % pattern.tasks.length];

    const taskStats = stats.byTask[taskTitle] || { completed: 0, skipped: 0 };
    taskStats.skipped++;
    stats.byTask[taskTitle] = taskStats;

    pattern.currentIndex = (currentTaskIndex + 1) % pattern.tasks.length;
  }

  saveTimeline(timeline);
}
```

### 4.6 Timeline 操作

#### 4.6.1 删除 Timeline

```typescript
interface RemoveTimelineParams {
  groupId: string;
  timelineId: string;
  force?: boolean; // 是否强制删除（忽略依赖检查）
}

function removeTimeline(params: RemoveTimelineParams): void {
  const timeline = findTimeline(params.timelineId);

  if (!timeline) {
    throw new Error('Timeline 不存在');
  }

  // 检查是否有其他节点依赖该 Timeline
  if (!params.force) {
    const dependentNodes = findNodesDependingOnTimeline(params.timelineId);
    if (dependentNodes.length > 0) {
      throw new Error('有其他节点依赖该 Timeline，不能删除');
    }
  }

  // 后置条件
  // 1. 从 TimelineGroup.timelines 移除
  removeTimelineFromGroup(params.groupId, params.timelineId);

  // 2. 如果 force === true，移除所有指向该 Timeline 的依赖
  if (params.force) {
    removeAllDependenciesToTimeline(params.timelineId);
  }

  // 3. 触发所有依赖该 Timeline 的节点的 lock 状态重新计算
  const dependentNodes = findNodesDependingOnTimeline(params.timelineId);
  for (const { timelineId, nodeId } of dependentNodes) {
    updateNodeLockStatus(timelineId, nodeId);
  }
}
```

---

## 5. 数据持久化与同步

### 5.1 存储格式

- **格式**: YAML
- **文件结构**:
  ```
  data/
    ├── timelines.yaml     # 主数据文件
    └── .sync/
          └── metadata.json # 同步元数据
  ```

### 5.2 YAML 示例（v3.0）

```yaml
version: '3.0'
metadata:
  lastModified: '2025-10-15T15:01:47Z'
  syncStatus: 'synced'

groups:
  - id: 'daily-life'
    title: '日常生活'
    timelines:
      # 普通时间线
      - id: 'travel-prep'
        title: '旅行准备'
        status: 'doing'
        nodes:
          - id: 'visa-node'
            type: 'task'
            title: '办理签证'
            status: 'done'
            mode:
              mode: 'scheduled'
              scheduledConfig:
                deadline: '2025-10-20T00:00:00Z'

          - id: 'booking-group'
            type: 'group'
            title: '预订事项'
            status: 'lock'
            depends_on_timeline: ['visa-timeline', 'insurance-timeline']
            subtasks:
              - id: 'book-flight'
                title: '订机票'
                status: 'todo'
              - id: 'book-hotel'
                title: '订酒店'
                status: 'todo'

        dependencies:
          - id: 'dep-multi-tl'
            type: 'timeline'
            from: ['visa-timeline', 'insurance-timeline']
            to: 'booking-group'
            description: '签证和保险都办好才能预订'

      # 循环时间线（每日任务轮换）
      - id: 'morning-routine'
        title: '晨间例行'
        # 注意：没有 nodes 字段
        recurrence:
          frequency: 'daily'
          pattern:
            tasks: ['冥想10分钟', '阅读30分钟', '写日记']
            currentIndex: 2
          stats:
            totalCompleted: 45
            totalSkipped: 3
            lastCompleted: '2025-10-15T07:30:00Z'
            byTask:
              '冥想10分钟': { completed: 15, skipped: 1 }
              '阅读30分钟': { completed: 15, skipped: 1 }
              '写日记': { completed: 15, skipped: 1 }
          active: true
        status: 'todo'

      # 循环时间线（每周指定日期+时长分摊）
      - id: 'weekly-fitness'
        title: '健身计划'
        recurrence:
          frequency: 'weekly'
          weeklyConfig:
            weekdays: [1, 3, 5] # 周一、三、五
            totalDuration: 3 # 每周总共3小时
            durationPerWeek: 1 # 每次1小时
          pattern:
            tasks: ['力量训练', '有氧运动']
            currentIndex: 0
          stats:
            totalCompleted: 12
            totalSkipped: 1
            byTask:
              '力量训练': { completed: 6, skipped: 0 }
              '有氧运动': { completed: 6, skipped: 1 }
          active: true
        status: 'todo'

      # 循环时间线（每月指定日期）
      - id: 'monthly-review'
        title: '月度回顾'
        recurrence:
          frequency: 'monthly'
          monthlyConfig:
            days: [1, 15] # 每月1号和15号
          pattern:
            tasks: ['工作回顾', '财务回顾']
          stats:
            totalCompleted: 6
            totalSkipped: 0
          active: true
        status: 'todo'

  - id: 'work-projects'
    title: '工作项目'
    timelines:
      # 多分支 fork 示例
      - id: 'project-alpha'
        title: '项目 Alpha 启动'
        nodes:
          - id: 'kickoff'
            type: 'task'
            title: '项目启动会'
            status: 'done'

          - id: 'design-phase'
            type: 'task'
            title: '设计阶段'
            status: 'doing'
            mode:
              mode: 'quantitative'
              quantitativeConfig:
                target: 5 # 需要完成5个设计稿
                current: 2 # 已完成2个
                unit: '个'

        dependencies:
          - id: 'dep-multi-split'
            type: 'split'
            from: 'kickoff'
            to: ['frontend-tl', 'backend-tl', 'design-tl']
            description: '启动会后分三条线并行开发'
```

### 5.3 WebDAV 同步策略

- **冲突解决**: Last-Write-Wins（最后写入优先）
- **同步触发**:
  - 应用启动时
  - 数据变更后延迟 5 秒
  - 用户手动触发
- **同步后操作**:
  - 重新计算所有节点的 lock 状态
  - 更新 Timeline 状态
- **错误处理**:
  - 同步失败时保留本地数据
  - 显示同步状态指示器
  - 提供手动重试选项

### 5.4 数据验证

```typescript
import { z } from 'zod';

const NodeStatusSchema = z.enum(['todo', 'doing', 'done', 'skipped', 'lock']);

const TaskModeConfigSchema = z.object({
  mode: z.enum(['scheduled', 'quantitative']),
  scheduledConfig: z
    .object({
      deadline: z.string().optional(),
      reminder: z.string().optional(),
    })
    .optional(),
  quantitativeConfig: z
    .object({
      target: z.number(),
      current: z.number(),
      unit: z.string().optional(),
    })
    .optional(),
});

const DependencySchema = z.object({
  id: z.string(),
  type: z.enum(['normal', 'split', 'timeline']),
  from: z.union([z.string(), z.array(z.string())]),
  to: z.union([z.string(), z.array(z.string())]),
  description: z.string().optional(),
});

const SubTaskSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  status: NodeStatusSchema,
  mode: TaskModeConfigSchema.optional(),
  // SubTask 不支持任何依赖字段
});

const BaseNodeSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  status: NodeStatusSchema,
  mode: TaskModeConfigSchema.optional(),
  depends_on: z.array(z.string()).optional(),
  depends_on_timeline: z.array(z.string()).optional(),
});

const NodeSchema = z.discriminatedUnion('type', [
  BaseNodeSchema.extend({
    type: z.literal('task'),
  }),
  BaseNodeSchema.extend({
    type: z.literal('group'),
    subtasks: z.array(SubTaskSchema),
  }),
]);

const RecurrenceConfigSchema = z.object({
  frequency: z.enum(['daily', 'weekly', 'monthly']),
  weeklyConfig: z
    .object({
      weekdays: z.array(z.number().min(0).max(6)),
      totalDuration: z.number().optional(),
      durationPerWeek: z.number().optional(),
    })
    .optional(),
  monthlyConfig: z
    .object({
      days: z.array(z.number().min(1).max(31)),
    })
    .optional(),
  pattern: z
    .object({
      tasks: z.array(z.string()),
      currentIndex: z.number().optional(),
    })
    .optional(),
  stats: z.object({
    totalCompleted: z.number(),
    totalSkipped: z.number(),
    lastCompleted: z.string().optional(),
    lastSkipped: z.string().optional(),
    byTask: z
      .record(
        z.object({
          completed: z.number(),
          skipped: z.number(),
        }),
      )
      .optional(),
  }),
  active: z.boolean(),
});

const TimelineSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  nodes: z.array(NodeSchema),
  dependencies: z.array(DependencySchema).optional(),
  recurrence: RecurrenceConfigSchema.optional(),
  status: z.enum(['todo', 'doing', 'done']).optional(),
});

const TimelineGroupSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  timelines: z.array(TimelineSchema),
});

const RootDataSchema = z.object({
  version: z.string(),
  groups: z.array(TimelineGroupSchema),
  metadata: z
    .object({
      lastModified: z.string(),
      syncStatus: z.enum(['synced', 'pending', 'error']).optional(),
    })
    .optional(),
});
```

## 6. 备忘条功能模块 (Memo Module)

### 6.1 功能定位

- 一个独立于核心 Timeline 功能的通用备忘录工具。
- 本质是一个可视化的 YAML 编辑器，用于快速记录、组织结构化信息，如代码片段、配置、API 草稿等。
- 数据应独立存储，不与 `timelines.yaml` 混合。

### 6.2 数据模型

- 根节点为一个 YAML 文档，可以是对象（Mapping）或数组（Sequence）。
- 支持 YAML 基础数据类型：
  - `string` (字符串)
  - `number` (数字)
  - `boolean` (布尔值)
  - `array` (数组/Sequence)
  - `object` (对象/Mapping)
- 数据独立存储于 `data/memo.yaml` 文件中。

### 6.3 核心操作

- **可视化编辑**: 所有操作均通过 UI 完成，用户无需直接编写 YAML。
- **添加条目**:
  - 在对象中添加新的键值对。
  - 在数组中添加新的元素。
  - 支持添加同级节点和子节点。
- **删除条目**: 删除选定的节点（及其所有子节点）。
- **编辑条目**:
  - 修改键名（如果父节点是对象）。
  - 修改值。
- **切换类型**:
  - 支持将一个节点的值在不同的数据类型之间切换。
  - 示例：`string` -> `number`, `string` -> `object` (空对象)。
- **同级排序**:
  - 在数组中，支持通过拖拽或“上/下移动”按钮调整元素顺序。
  - 在对象中，支持调整键值对的顺序。

### 6.4 UI/UX 需求

- **树状视图**: 以可展开/折叠的树状结构展示 YAML 数据，清晰反映层级关系。
- **内联操作**: 每个节点旁边应有清晰的操作按钮（如：添加、删除、编辑、移动）。
- **拖拽支持**: 支持拖拽节点以实现排序和层级变更。
