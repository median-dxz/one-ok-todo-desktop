# One Ok Todo 需求文档 v4.0

## 1. 应用定位与核心价值

### 1.1 应用定位

单人使用的时间线型任务管理工具，以"时间线思维"组织任务，而非传统的列表或看板模式。

### 1.2 核心特性

- **时间线优先**: 任务以时间线（Timeline）为组织单位，体现事件的顺序性
- **多维依赖关系**: 支持节点间依赖、跨 Timeline 依赖、多分支依赖
- **灵活循环任务**: 支持多种循环模式、任务轮换、定时/定量执行
- **备忘条功能**: 可视化 YAML 编辑器，支持条目切换类型与同级排序
- **多端同步**: 通过 WebDAV 实现数据同步

---

## 2. 数据模型定义

### 2.2.1 节点总体数据模型

根据代码的实际定义，数据模型区分了不同层级的节点类型。有一个最基础的 `BaseNode`，以及一个扩展了更丰富属性的 `TaskNode`。

```typescript
// 基础节点属性
export interface BaseNode {
  id: string; // 节点唯一标识
  title: string; // 节点标题
  type: string; // 节点的具体类型，如 'task' 或 'sub-task'
  status: NodeStatus; // 节点状态
}

// 普通任务节点
export interface TaskNode extends BaseNode {
  type: 'task';

  // 依赖关系
  prevs: string[]; // 前驱节点 ID 列表
  succs: string[]; // 后继节点 ID 列表

  mode?: TaskModeConfig; // 任务执行模式
  subtasks?: SubTask[]; // 子任务列表
  milestone?: boolean; // 里程碑，用户手动高亮的节点
}

// 子任务
export interface SubTask extends BaseNode {
  type: 'sub-task';
}
```

`milestone` 字段是用户手动设置的一个高亮标记，用于标识当前关注的重点任务或里程碑，它独立于任务本身的完成状态。

### 2.2.2 节点状态（NodeStatus）

节点的状态完全由其在依赖关系图中的位置和前驱节点的状态决定，简化了心智负担。

| 状态      | 说明   | 业务规则                                 | 触发条件         |
| --------- | ------ | ---------------------------------------- | ---------------- |
| `todo`    | 待办   | 所有前驱节点都已完成，当前节点可执行     | **系统自动计算** |
| `done`    | 已完成 | 用户手动标记为完成                       | 用户手动操作     |
| `skipped` | 已跳过 | 用户手动标记为跳过，视为一种特殊的`done` | 用户手动操作     |
| `locked`  | 已锁定 | 至少有一个前驱节点未完成，不可执行       | **系统自动计算** |

**状态计算规则**:

- **`locked`**: 只要 `prevs` 列表中有任何一个节点的状态不是 `done` 或 `skipped`，当前节点的状态就是 `locked`。
- **`todo`**: 当 `prevs` 列表中的所有节点状态都是 `done` 或 `skipped` 时，当前节点的状态自动变为 `todo`，包括前驱节点不存在的情况。
- **`done` / `skipped`**: 这两个状态由用户手动设置。一个节点被标记为 `done` 或 `skipped` 后，会触发其所有 `succs` 后继节点的状态重新计算，可能使其从 `locked` 变为 `todo`。

### 2.2.3 任务执行模式（TaskMode）

这里定义了任务的两种完成方式：“定时模式”（scheduled）和“定量模式”（quantitative）。定时模式关心的是任务是否有截止日期；定量模式则关心任务需要完成的次数或数量，例如“读 5 本书”。

**执行模式说明**:

- `scheduled`: 定时模式，任务到达指定时间前执行完成
- `quantitative`: 定量模式，需要完成指定数量才算完成

### 2.2.4 节点类型

`TimelineNode` 类型目前只包含 `TaskNode`，但数据结构上通过 `type` 字段（如 `'task'`, `'sub-task'`）的设计，保留了未来扩展不同节点类型的能力。`TaskNode` 是构成时间线的主体，它可以包含自己的依赖、子任务和各种配置。`SubTask` 是一种结构更简单的节点，用于 `TaskNode` 内部。

### 2.2.5 时间线结构

这里定义了“时间线”（Timeline）的构成。一条时间线包含标题、一系列按顺序排列的任务节点、以及这些节点间的依赖关系。

### 2.2.6 时间线分组

定义了“时间线分组”（TimelineGroup），它就像一个文件夹，可以把多条相关的“时间线”组织在一起，比如一个“工作”分组，一个“生活”分组。

时间线上的节点不能跨组添加依赖关系。

### 2.2.7 循环任务

循环任务是一种特殊的时间线，该时间线上面没有任务节点，而是根据当前的日期自动无限生成对应的节点，同时也记录了已经完成和跳过的任务，用于统计。

循环的种类有：天、周、月，每周的话可以指定周几，每月可以指定几号，还支持多个任务轮换执行（比如健身时“胸、背、腿”轮着来）。

同时支持将周/月任务按天均摊，均摊的可以是次数或者时间。

**循环任务特性**:

- **不包含 nodes 数组**: 循环任务的节点由时间计算生成，不持久化存储
- **统计信息**: 记录总完成次数、跳过次数等
- **任务轮换**: 支持 ABCABC 模式，每次循环使用不同的任务
- **时间生成逻辑**: 根据 `recurrence.frequency` 和时间参数自动计算当前周期的任务实例

## 3. 核心操作定义

### 3.1 时间线操作

#### 3.1.1 创建时间线

用户可以创建一个新的时间线，新创建的时间线是空的，不附带任何初始节点。

#### 3.1.2 编辑时间线

用户可以修改已有时间线的标题等基本信息。

#### 3.1.3 删除时间线

用户可以删除一个时间线。删除时，会一并移除其中包含的所有节点和相关的依赖关系。

### 3.2 分组操作

#### 3.2.1 创建/编辑/删除分组

用户可以创建新的时间线分组（文件夹），或编辑已有分组的名称。

### 3.3 节点基础操作

#### 3.3.1 创建节点

用户可以在时间线内创建一个新节点。创建时，可以选择性地指定其前驱（`prevs`）和后继（`succs`）节点，从而将其精确地插入到依赖关系图的特定位置。

#### 3.3.2 删除节点

当删除一个节点时，为了维持依赖关系的完整性，程序会自动将其所有前驱节点连接到其所有后继节点。例如，若 `A -> B -> C`，删除 B 后，依赖关系变为 `A -> C`。

#### 3.3.3 编辑节点

用户可以修改节点的标题、执行模式、子任务列表等内容属性。

#### 3.3.4 完成/跳过节点

用户可以手动将一个状态为 `todo` 的节点标记为 `done` 或 `skipped`。此操作会触发该节点所有后继（`succs`）节点的状态重新计算。

#### 3.3.5 撤销完成

用户可以将一个 `done` 或 `skipped` 状态的节点撤销回 `todo` 状态，但必须满足以下**严格条件**：

- 该节点的所有前驱（`prevs`）节点必须都处于 `done` 或 `skipped` 状态。
- 该节点的所有后继（`succs`）节点必须都处于 `todo` 或 `locked` 状态。

### 3.4 节点高级图操作

#### 3.4.1 添加依赖（Merge）

用户可以在两个节点之间创建新的依赖关系，例如从节点 A 连接到节点 B，使 B 依赖于 A。此操作必须满足以下条件：

- 两个节点的状态都必须是 `todo` 或 `locked`。
- 两个节点处于同一个 Timeline 组。
- 添加新的依赖关系后，整个项目的所有节点必须依然构成一个有向无环图（DAG），不允许出现循环依赖。

#### 3.4.2 创建并行分支（Fork）

此操作允许用户从一个现有节点（源节点）出发，创建一个新的并行工作流。具体流程如下：

1. 在源节点之后创建一个新的后继节点。
2. 创建一条全新的时间线。
3. 将这个新创建的后继节点作为新时间线的起始节点。

#### 3.4.3 回滚节点（Revert）

用户可以复制一个之前已处于 `done` 或 `skipped` 状态的节点，并将这个副本作为一个全新的 `todo` 节点添加到其所在时间线的末尾。此操作存在一个限制：

- 如果该时间线的最后一个节点存在一个位于**其他时间线**的后继节点，并且该后继节点也已完成（`done`/`skipped`），则不允许执行 Revert 操作，以防止破坏已完成的跨时间线依赖链。

#### 3.4.4 交换节点内容

此操作允许用户交换两个节点的内容信息，但保留它们在图中的位置和连接关系。具体要求：

- 两个节点的状态都必须是 `todo` 或 `locked`。
- 操作仅交换节点的“标签数据”（如标题、描述、子任务列表等），节点的 `id`、`prevs` 和 `succs` 保持不变。

## 4. 数据持久化与同步

### 4.1 存储格式

- **格式**: JSON
- **文件结构**:

```text
  data/
    ├── timelines.json      # 时间线数据
    ├── memos.json          # 备忘数据
    └── .sync/
          └── metadata.json # 同步元数据
```

### 4.2 WebDAV 同步策略

- **冲突解决**: Last-Write-Wins（最后写入优先）
- **同步触发**:
  - 应用启动时
  - 数据变更后延迟 5 秒
  - 用户手动触发
- **同步后操作**:
  - 重新计算所有节点的 lock 状态
  - 更新 Timeline 状态
- **错误处理**:
  - 同步失败时保留本地数据
  - 显示同步状态指示器
  - 提供手动重试选项

## 5. 备忘条功能模块 (Memo Module)

### 5.1 功能定位

- 一个独立于核心 Timeline 功能的通用备忘录工具。
- 本质是一个可视化的 YAML 编辑器，用于快速记录、组织结构化信息，如代码片段、配置、API 草稿等。
- 数据应独立存储，不与 `timelines.yaml` 混合。

### 5.2 数据模型

- 根节点为一个 YAML 文档，可以是对象（Mapping）或数组（Sequence）。
- 支持 YAML 基础数据类型：
  - `string` (字符串)
  - `number` (数字)
  - `boolean` (布尔值)
  - `array` (数组/Sequence)
  - `object` (对象/Mapping)
- 数据独立存储于 `data/memo.yaml` 文件中。

### 5.3 核心操作

- **可视化编辑**: 所有操作均通过 UI 完成，用户无需直接编写 YAML。
- **添加条目**:
  - 在对象中添加新的键值对。
  - 在数组中添加新的元素。
  - 支持添加同级节点和子节点。
- **删除条目**: 删除选定的节点（及其所有子节点）。
- **编辑条目**:
  - 修改键名（如果父节点是对象）。
  - 修改值。
- **切换类型**:
  - 支持将一个节点的值在不同的数据类型之间切换。
  - 示例：`string` -> `number`, `string` -> `object` (空对象)。
- **同级排序**:
  - 在数组中，支持通过拖拽或“上/下移动”按钮调整元素顺序。
  - 在对象中，支持调整键值对的顺序。

### 5.4 UI/UX 需求

- **树状视图**: 以可展开/折叠的树状结构展示 YAML 数据，清晰反映层级关系。
- **内联操作**: 每个节点旁边应有清晰的操作按钮（如：添加、删除、编辑、移动）。
- **拖拽支持**: 支持拖拽节点以实现排序和层级变更。
