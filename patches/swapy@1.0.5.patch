diff --git a/dist/swapy.js b/dist/swapy.js
index c73b1d8bed6923e0d649c38f7ec3ed5e1573b337..bd9f6de630cb51729f916a0d7f047c02199f45e7 100644
--- a/dist/swapy.js
+++ b/dist/swapy.js
@@ -1,7 +1,7 @@
-function rt(t) {
+function it(t) {
   return typeof t == "object" && t !== null && "x" in t && "y" in t && "unit" in t && typeof t.unit == "string" && typeof t.x == "object" && typeof t.y == "object" && "topLeft" in t.x && "topRight" in t.x && "bottomRight" in t.x && "bottomLeft" in t.x && "topLeft" in t.y && "topRight" in t.y && "bottomRight" in t.y && "bottomLeft" in t.y;
 }
-function gt(t) {
+function ht(t) {
   var h;
   const e = t.match(/(\d+(?:\.\d+)?)(px|%)/g);
   if (!e)
@@ -10,17 +10,17 @@ function gt(t) {
       y: { topLeft: 0, topRight: 0, bottomRight: 0, bottomLeft: 0 },
       unit: "px"
     };
-  const n = e.map((c) => {
-    const [s, f, y] = c.match(/(\d+(?:\.\d+)?)(px|%)/) ?? [];
-    return { value: parseFloat(f), unit: y };
+  const n = e.map((f) => {
+    const [s, u, y] = f.match(/(\d+(?:\.\d+)?)(px|%)/) ?? [];
+    return { value: parseFloat(u), unit: y };
   }), o = ((h = n[0]) == null ? void 0 : h.unit) || "px";
-  if (n.some((c) => c.unit !== o))
+  if (n.some((f) => f.unit !== o))
     throw new Error("Inconsistent units in border-radius string.");
-  const [l, i, d, u] = n.map((c) => c.value), a = {
+  const [l, i, d, c] = n.map((f) => f.value), a = {
     topLeft: l ?? 0,
     topRight: i ?? l ?? 0,
     bottomRight: d ?? l ?? 0,
-    bottomLeft: u ?? i ?? l ?? 0
+    bottomLeft: c ?? i ?? l ?? 0
   };
   return {
     x: { ...a },
@@ -28,7 +28,7 @@ function gt(t) {
     unit: o
   };
 }
-function ht({ x: t, y: e, unit: n }, o, l) {
+function pt({ x: t, y: e, unit: n }, o, l) {
   if (n === "px") {
     const i = {
       topLeft: t.topLeft / o,
@@ -46,17 +46,17 @@ function ht({ x: t, y: e, unit: n }, o, l) {
     return { x: t, y: e, unit: "%" };
   return { x: t, y: e, unit: n };
 }
-function G(t) {
+function Z(t) {
   return `
     ${t.x.topLeft}${t.unit} ${t.x.topRight}${t.unit} ${t.x.bottomRight}${t.unit} ${t.x.bottomLeft}${t.unit}
     /
     ${t.y.topLeft}${t.unit} ${t.y.topRight}${t.unit} ${t.y.bottomRight}${t.unit} ${t.y.bottomLeft}${t.unit}
   `;
 }
-function it(t) {
+function at(t) {
   return t.x.topLeft === 0 && t.x.topRight === 0 && t.x.bottomRight === 0 && t.x.bottomLeft === 0 && t.y.topLeft === 0 && t.y.topRight === 0 && t.y.bottomRight === 0 && t.y.bottomLeft === 0;
 }
-function at(t) {
+function st(t) {
   return typeof t == "object" && "x" in t && "y" in t;
 }
 function R(t, e) {
@@ -68,16 +68,16 @@ function xt(t, e) {
 function vt(t, e) {
   return R(t.x - e.x, t.y - e.y);
 }
-function It(t, e) {
+function At(t, e) {
   return R(t.x * e, t.y * e);
 }
 function C(t, e, n) {
   return t + (e - t) * n;
 }
-function At(t, e, n) {
-  return xt(t, It(vt(e, t), n));
+function Et(t, e, n) {
+  return xt(t, At(vt(e, t), n));
 }
-function pt(t, e, n) {
+function mt(t, e, n) {
   return {
     x: {
       topLeft: C(t.x.topLeft, e.x.topLeft, n),
@@ -94,48 +94,48 @@ function pt(t, e, n) {
     unit: t.unit
   };
 }
-function Et(t, e, n) {
-  return V((n - t) / (e - t), 0, 1);
+function It(t, e, n) {
+  return z((n - t) / (e - t), 0, 1);
 }
-function U(t, e, n, o, l) {
-  return C(n, o, Et(t, e, l));
+function G(t, e, n, o, l) {
+  return C(n, o, It(t, e, l));
 }
-function V(t, e, n) {
+function z(t, e, n) {
   return Math.min(Math.max(t, e), n);
 }
 const Xt = {
   duration: 350,
   easing: (t) => t
 };
-function mt(t, e, n, o) {
+function yt(t, e, n, o) {
   let l = !1;
   const i = () => {
     l = !0;
   }, d = { ...Xt, ...o };
-  let u;
+  let c;
   function a(h) {
-    u === void 0 && (u = h);
-    const c = h - u, s = V(c / d.duration, 0, 1), f = Object.keys(t), y = Object.keys(e);
-    if (!f.every((g) => y.includes(g))) {
+    c === void 0 && (c = h);
+    const f = h - c, s = z(f / d.duration, 0, 1), u = Object.keys(t), y = Object.keys(e);
+    if (!u.every((g) => y.includes(g))) {
       console.error("animate Error: `from` keys are different than `to`");
       return;
     }
-    const v = {};
-    f.forEach((g) => {
-      typeof t[g] == "number" && typeof e[g] == "number" ? v[g] = C(
+    const x = {};
+    u.forEach((g) => {
+      typeof t[g] == "number" && typeof e[g] == "number" ? x[g] = C(
         t[g],
         e[g],
         d.easing(s)
-      ) : rt(t[g]) && rt(e[g]) ? v[g] = pt(
+      ) : it(t[g]) && it(e[g]) ? x[g] = mt(
         t[g],
         e[g],
         d.easing(s)
-      ) : at(t[g]) && at(e[g]) && (v[g] = At(
+      ) : st(t[g]) && st(e[g]) && (x[g] = Et(
         t[g],
         e[g],
         d.easing(s)
       ));
-    }), n(v, s >= 1, s), s < 1 && !l && requestAnimationFrame(a);
+    }), n(x, s >= 1, s), s < 1 && !l && requestAnimationFrame(a);
   }
   return requestAnimationFrame(a), i;
 }
@@ -145,92 +145,106 @@ const Tt = {
 };
 function Mt(t, e) {
   const n = { ...Tt, ...e };
-  let o = t.el(), l = !1, i = null, d = null, u = null, a = null, h = 0, c = 0, s = 0, f = 0, y = 0, v = 0, g = 0, T = 0, r = 0, I = 0, E = null, p;
-  o.addEventListener("pointerdown", w), document.body.addEventListener("pointerup", x), document.body.addEventListener("pointermove", X), document.body.addEventListener("touchmove", M, { passive: !1 });
-  function w(m) {
+  let o = t.el(), l = !1, i = null, d = null, c = null, a = null, h = 0, f = 0, s = 0, u = 0, y = 0, x = 0, g = 0, T = 0, r = 0, E = 0, I = null, p = null, w;
+  o.addEventListener("pointerdown", A), document.body.addEventListener("pointerup", X), document.body.addEventListener("pointermove", M), document.body.addEventListener("touchmove", D, { passive: !1 });
+  function A(m) {
     if (n.targetEl && m.target !== n.targetEl && !n.targetEl.contains(m.target) || l || !m.isPrimary) return;
-    n.startDelay > 0 ? (u == null || u({ el: m.target }), p = setTimeout(() => {
+    if (n.startDelay > 0) {
+      c == null || c({ el: m.target }), p = null;
+      let b = m.target;
+      for (; b && p == null; ) {
+        if (b.hasAttribute("data-swapy-item")) {
+          p = b;
+          break;
+        }
+        b = b.parentElement;
+      }
+      w = setTimeout(() => {
+        B();
+      }, n.startDelay);
+    } else
       B();
-    }, n.startDelay)) : B();
     function B() {
-      E = m.target;
-      const L = t.boundingRect(), F = t.layoutRect();
-      y = F.x, v = F.y, s = L.x - y, f = L.y - v, h = m.clientX - s, c = m.clientY - f, g = m.clientX, T = m.clientY, r = (m.clientX - L.x) / L.width, I = (m.clientY - L.y) / L.height, l = !0, X(m);
+      I = m.target;
+      const b = t.boundingRect(), W = t.layoutRect();
+      y = W.x, x = W.y, s = b.x - y, u = b.y - x, h = m.clientX - s, f = m.clientY - u, g = m.clientX, T = m.clientY, r = (m.clientX - b.x) / b.width, E = (m.clientY - b.y) / b.height, l = !0, M(m);
     }
   }
-  function A() {
+  function v() {
     const m = t.layoutRect();
-    h -= y - m.x, c -= v - m.y, y = m.x, v = m.y;
+    h -= y - m.x, f -= x - m.y, y = m.x, x = m.y;
   }
-  function x(m) {
+  function X(m) {
     if (!l) {
-      p && (clearTimeout(p), p = null, a == null || a({ el: m.target }));
+      w && (clearTimeout(w), p = null, w = null, a == null || a({ el: m.target }));
       return;
     }
     if (!m.isPrimary) return;
     l = !1;
-    const B = m.clientX - g, L = m.clientY - T;
+    const B = m.clientX - g, b = m.clientY - T;
     d == null || d({
       x: s,
-      y: f,
+      y: u,
       pointerX: m.clientX,
       pointerY: m.clientY,
       width: B,
-      height: L,
+      height: b,
       relativeX: r,
-      relativeY: I,
-      el: E
-    }), E = null;
+      relativeY: E,
+      el: I
+    }), I = null;
   }
-  function X(m) {
+  function M(m) {
     if (!l) {
-      p && (clearTimeout(p), p = null, a == null || a({ el: m.target }));
+      if (p && (p === m.target || p.contains(m.target)))
+        return;
+      w && (clearTimeout(w), c = null, w = null, a == null || a({ el: m.target }));
       return;
     }
     if (!m.isPrimary) return;
-    const B = m.clientX - g, L = m.clientY - T, F = s = m.clientX - h, Z = f = m.clientY - c;
+    const B = m.clientX - g, b = m.clientY - T, W = s = m.clientX - h, K = u = m.clientY - f;
     i == null || i({
       width: B,
-      height: L,
-      x: F,
-      y: Z,
+      height: b,
+      x: W,
+      y: K,
       pointerX: m.clientX,
       pointerY: m.clientY,
       relativeX: r,
-      relativeY: I,
-      el: E
+      relativeY: E,
+      el: I
     });
   }
-  function M(m) {
+  function D(m) {
     if (!l) return !0;
     m.preventDefault();
   }
-  function D(m) {
-    i = m;
-  }
   function H(m) {
-    d = m;
+    i = m;
   }
   function _(m) {
-    u = m;
+    d = m;
   }
   function P(m) {
-    a = m;
+    c = m;
   }
-  function $() {
-    o.removeEventListener("pointerdown", w), o = t.el(), o.addEventListener("pointerdown", w);
+  function $(m) {
+    a = m;
   }
   function N() {
-    t.el().removeEventListener("pointerdown", w), document.body.removeEventListener("pointerup", x), document.body.removeEventListener("pointermove", X), document.body.removeEventListener("touchmove", M), i = null, d = null, u = null, a = null;
+    o.removeEventListener("pointerdown", A), o = t.el(), o.addEventListener("pointerdown", A);
+  }
+  function q() {
+    t.el().removeEventListener("pointerdown", A), document.body.removeEventListener("pointerup", X), document.body.removeEventListener("pointermove", M), document.body.removeEventListener("touchmove", D), i = null, d = null, c = null, a = null;
   }
   return {
-    onDrag: D,
-    onDrop: H,
-    onHold: _,
-    onRelease: P,
-    onElementUpdate: $,
-    destroy: N,
-    readjust: A
+    onDrag: H,
+    onDrop: _,
+    onHold: P,
+    onRelease: $,
+    onElementUpdate: N,
+    destroy: q,
+    readjust: v
   };
 }
 function Dt(t) {
@@ -239,7 +253,7 @@ function Dt(t) {
 function bt(t) {
   return 1 - Math.pow(1 - t, 3);
 }
-function z(t) {
+function U(t) {
   return {
     x: t.x,
     y: t.y,
@@ -253,9 +267,9 @@ function Lt(t) {
   for (; l; ) {
     const d = getComputedStyle(l).transform;
     if (d && d !== "none") {
-      const u = d.match(/matrix.*\((.+)\)/);
-      if (u) {
-        const a = u[1].split(", ").map(Number);
+      const c = d.match(/matrix.*\((.+)\)/);
+      if (c) {
+        const a = c[1].split(", ").map(Number);
         n += a[4] || 0, o += a[5] || 0;
       }
     }
@@ -268,7 +282,7 @@ function Lt(t) {
     height: e.height
   };
 }
-function J(t) {
+function Q(t) {
   let e = t, n = 0, o = 0;
   for (; e; )
     n += e.offsetTop, o += e.offsetLeft, e = e.offsetParent;
@@ -279,7 +293,7 @@ function J(t) {
     height: t.offsetHeight
   };
 }
-function st(t, e) {
+function ct(t, e) {
   return t.x >= e.x && t.x <= e.x + e.width && t.y >= e.y && t.y <= e.y + e.height;
 }
 function Yt(t) {
@@ -299,55 +313,55 @@ function Yt(t) {
   }
   return { x: o, y: n };
 }
-function Q(t) {
-  let e = "unread", n, o, l, i, d, u, a, h, c, s, f;
+function tt(t) {
+  let e = "unread", n, o, l, i, d, c, a, h, f, s, u;
   function y() {
-    n = t.currentTransform(), o = Lt(t.el()), l = Yt(t.el()), f = ct(t.el()).map(({ parent: I, children: E }) => ({
+    n = t.currentTransform(), o = Lt(t.el()), l = Yt(t.el()), u = ft(t.el()).map(({ parent: E, children: I }) => ({
       parent: {
-        el: I,
-        initialRect: z(I.getBoundingClientRect())
+        el: E,
+        initialRect: U(E.getBoundingClientRect())
       },
-      children: E.filter((p) => p instanceof HTMLElement).map((p) => {
+      children: I.filter((p) => p instanceof HTMLElement).map((p) => {
         const w = p;
         return w.originalBorderRadius || (w.originalBorderRadius = getComputedStyle(p).borderRadius), {
           el: p,
-          borderRadius: gt(w.originalBorderRadius),
-          initialRect: z(
+          borderRadius: ht(w.originalBorderRadius),
+          initialRect: U(
             p.getBoundingClientRect()
           )
         };
       })
     })), e = "readInitial";
   }
-  function v() {
+  function x() {
     if (e !== "readInitial")
       throw new Error(
         "FlipView: Cannot read final values before reading initial values"
       );
-    c = t.layoutRect(), u = o.width / c.width, a = o.height / c.height, i = o.x - c.x - n.dragX + l.x, d = o.y - c.y - n.dragY + l.y, h = ht(
+    f = t.layoutRect(), c = o.width / f.width, a = o.height / f.height, i = o.x - f.x - n.dragX + l.x, d = o.y - f.y - n.dragY + l.y, h = pt(
       t.borderRadius(),
-      u,
+      c,
       a
     );
-    const r = ct(t.el());
-    f = f.map(
-      ({ parent: E, children: p }, w) => {
+    const r = ft(t.el());
+    u = u.map(
+      ({ parent: I, children: p }, w) => {
         const A = r[w].parent;
         return {
           parent: {
-            ...E,
+            ...I,
             el: A,
-            finalRect: J(A)
+            finalRect: Q(A)
           },
-          children: p.map((x, X) => {
+          children: p.map((v, X) => {
             const M = r[w].children[X];
-            let D = J(M);
+            let D = Q(M);
             return M.hasAttribute("data-swapy-text") && (D = {
               ...D,
-              width: x.initialRect.width,
-              height: x.initialRect.height
+              width: v.initialRect.width,
+              height: v.initialRect.height
             }), {
-              ...x,
+              ...v,
               el: M,
               finalRect: D
             };
@@ -355,23 +369,23 @@ function Q(t) {
         };
       }
     );
-    const I = {
+    const E = {
       translateX: i,
       translateY: d,
-      scaleX: u,
+      scaleX: c,
       scaleY: a
     };
-    t.el().style.transformOrigin = "0 0", t.el().style.borderRadius = G(
+    t.el().style.transformOrigin = "0 0", t.el().style.borderRadius = Z(
       h
-    ), t.setTransform(I), s = [], f.forEach(({ parent: E, children: p }) => {
+    ), t.setTransform(E), s = [], u.forEach(({ parent: I, children: p }) => {
       const w = p.map(
-        ({ el: A, initialRect: x, finalRect: X, borderRadius: M }) => Ct(
+        ({ el: A, initialRect: v, finalRect: X, borderRadius: M }) => Ct(
           A,
-          x,
+          v,
           X,
           M,
-          E.initialRect,
-          E.finalRect
+          I.initialRect,
+          I.finalRect
         )
       );
       s.push(...w);
@@ -385,12 +399,12 @@ function Q(t) {
         width: o.width,
         height: o.height,
         translate: R(i, d),
-        scale: R(u, a),
+        scale: R(c, a),
         borderRadius: h
       },
       to: {
-        width: c.width,
-        height: c.height,
+        width: f.width,
+        height: f.height,
         translate: R(0, 0),
         scale: R(1, 1),
         borderRadius: t.borderRadius()
@@ -406,28 +420,28 @@ function Q(t) {
   }
   return {
     readInitial: y,
-    readFinalAndReverse: v,
+    readFinalAndReverse: x,
     transitionValues: g,
     childrenTransitionData: T
   };
 }
 function Ct(t, e, n, o, l, i) {
   t.style.transformOrigin = "0 0";
-  const d = l.width / i.width, u = l.height / i.height, a = e.width / n.width, h = e.height / n.height, c = ht(
+  const d = l.width / i.width, c = l.height / i.height, a = e.width / n.width, h = e.height / n.height, f = pt(
     o,
     a,
     h
-  ), s = e.x - l.x, f = n.x - i.x, y = e.y - l.y, v = n.y - i.y, g = (s - f * d) / d, T = (y - v * u) / u;
-  return t.style.transform = `translate(${g}px, ${T}px) scale(${a / d}, ${h / u})`, t.style.borderRadius = G(c), {
+  ), s = e.x - l.x, u = n.x - i.x, y = e.y - l.y, x = n.y - i.y, g = (s - u * d) / d, T = (y - x * c) / c;
+  return t.style.transform = `translate(${g}px, ${T}px) scale(${a / d}, ${h / c})`, t.style.borderRadius = Z(f), {
     el: t,
     fromTranslate: R(g, T),
     fromScale: R(a, h),
-    fromBorderRadius: c,
+    fromBorderRadius: f,
     toBorderRadius: o,
-    parentScale: { x: d, y: u }
+    parentScale: { x: d, y: c }
   };
 }
-function ct(t) {
+function ft(t) {
   const e = [];
   function n(o) {
     const l = Array.from(o.children).filter(
@@ -440,7 +454,7 @@ function ct(t) {
   }
   return n(t), e;
 }
-function yt(t) {
+function wt(t) {
   const e = [];
   let n = t, o = {
     dragX: 0,
@@ -450,24 +464,24 @@ function yt(t) {
     scaleX: 1,
     scaleY: 1
   };
-  const l = gt(
+  const l = ht(
     window.getComputedStyle(n).borderRadius
   ), i = {
     el: () => n,
     setTransform: d,
-    clearTransform: u,
+    clearTransform: c,
     currentTransform: () => o,
     borderRadius: () => l,
-    layoutRect: () => J(n),
-    boundingRect: () => z(n.getBoundingClientRect()),
+    layoutRect: () => Q(n),
+    boundingRect: () => U(n.getBoundingClientRect()),
     usePlugin: h,
-    destroy: c,
+    destroy: f,
     updateElement: s
   };
-  function d(f) {
-    o = { ...o, ...f }, a();
+  function d(u) {
+    o = { ...o, ...u }, a();
   }
-  function u() {
+  function c() {
     o = {
       dragX: 0,
       dragY: 0,
@@ -478,20 +492,20 @@ function yt(t) {
     }, a();
   }
   function a() {
-    const { dragX: f, dragY: y, translateX: v, translateY: g, scaleX: T, scaleY: r } = o;
-    f === 0 && y === 0 && v === 0 && g === 0 && T === 1 && r === 1 ? n.style.transform = "" : n.style.transform = `translate(${f + v}px, ${y + g}px) scale(${T}, ${r})`;
+    const { dragX: u, dragY: y, translateX: x, translateY: g, scaleX: T, scaleY: r } = o;
+    u === 0 && y === 0 && x === 0 && g === 0 && T === 1 && r === 1 ? n.style.transform = "" : n.style.transform = `translate(${u + x}px, ${y + g}px) scale(${T}, ${r})`;
   }
-  function h(f, y) {
-    const v = f(i, y);
-    return e.push(v), v;
+  function h(u, y) {
+    const x = u(i, y);
+    return e.push(x), x;
   }
-  function c() {
-    e.forEach((f) => f.destroy());
+  function f() {
+    e.forEach((u) => u.destroy());
   }
-  function s(f) {
-    if (!f) return;
-    const y = n.hasAttribute("data-swapy-dragging"), v = n.style.cssText;
-    n = f, y && n.setAttribute("data-swapy-dragging", ""), n.style.cssText = v, e.forEach((g) => g.onElementUpdate());
+  function s(u) {
+    if (!u) return;
+    const y = n.hasAttribute("data-swapy-dragging"), x = n.style.cssText;
+    n = u, y && n.setAttribute("data-swapy-dragging", ""), n.style.cssText = x, e.forEach((g) => g.onElementUpdate());
   }
   return i;
 }
@@ -510,20 +524,20 @@ function Ht(t, e) {
 }
 function $t(t, e, n, o, l, i = !1) {
   const d = e.filter(
-    (h) => !o.some((c) => c.item === h[n])
+    (h) => !o.some((f) => f.item === h[n])
   ).map((h) => ({
     slot: h[n],
     item: h[n]
   }));
-  let u;
-  i ? u = o.map((h) => e.some((c) => c[n] === h.item) ? h : { slot: h.slot, item: "" }) : u = o.filter(
-    (h) => e.some((c) => c[n] === h.item) || !h.item
+  let c;
+  i ? c = o.map((h) => e.some((f) => f[n] === h.item) ? h : { slot: h.slot, item: "" }) : c = o.filter(
+    (h) => e.some((f) => f[n] === h.item) || !h.item
   );
   const a = [
-    ...u,
+    ...c,
     ...d
   ];
-  l(a), (d.length > 0 || u.length !== o.length) && requestAnimationFrame(() => {
+  l(a), (d.length > 0 || c.length !== o.length) && requestAnimationFrame(() => {
     t == null || t.update();
   });
 }
@@ -541,7 +555,7 @@ const jt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
   dragAxis: "both",
   manualSwap: !1
 };
-function wt(t) {
+function St(t) {
   switch (t) {
     case "dynamic":
       return { easing: bt, duration: 300 };
@@ -565,15 +579,15 @@ function kt(t, e) {
     ), o.setSlots(l), i = Array.from(t.querySelectorAll("[data-swapy-item]")).map(
       (r) => Pt(r, o)
     ), o.setItems(i), o.syncSlotItemMap(), i.forEach((r) => {
-      r.onDrag(({ pointerX: I, pointerY: E }) => {
+      r.onDrag(({ pointerX: E, pointerY: I }) => {
         a();
         let p = !1;
         l.forEach((w) => {
           const A = w.rect();
-          st({ x: I, y: E }, A) && (p = !0, w.isHighlighted() || w.highlight());
-        }), !p && o.config().swapMode === "drop" && r.slot().highlight(), n.swapMode === "hover" && u(r, { pointerX: I, pointerY: E });
-      }), r.onDrop(({ pointerX: I, pointerY: E }) => {
-        h(), n.swapMode === "drop" && u(r, { pointerX: I, pointerY: E });
+          ct({ x: E, y: I }, A) && (p = !0, w.isHighlighted() || w.highlight());
+        }), !p && o.config().swapMode === "drop" && r.slot().highlight(), n.swapMode === "hover" && c(r, { pointerX: E, pointerY: I });
+      }), r.onDrop(({ pointerX: E, pointerY: I }) => {
+        h(), n.swapMode === "drop" && c(r, { pointerX: E, pointerY: I });
       }), r.onHold(() => {
         a();
       }), r.onRelease(() => {
@@ -581,29 +595,29 @@ function kt(t, e) {
       });
     });
   }
-  function u(r, { pointerX: I, pointerY: E }) {
+  function c(r, { pointerX: E, pointerY: I }) {
     l.forEach((p) => {
       const w = p.rect();
-      if (st({ x: I, y: E }, w)) {
+      if (ct({ x: E, y: I }, w)) {
         if (r.id() === p.itemId()) return;
         o.config().swapMode === "hover" && r.setContinuousDrag(!0);
-        const A = r.slot(), x = p.item();
+        const A = r.slot(), v = p.item();
         if (!o.eventHandlers().onBeforeSwap({
           fromSlot: A.id(),
           toSlot: p.id(),
           draggingItem: r.id(),
-          swapWithItem: (x == null ? void 0 : x.id()) || ""
+          swapWithItem: (v == null ? void 0 : v.id()) || ""
         }))
           return;
         if (o.config().manualSwap) {
           const X = structuredClone(o.slotItemMap());
           o.swapItems(r, p);
-          const M = o.slotItemMap(), D = Q(r.view());
+          const M = o.slotItemMap(), D = tt(r.view());
           D.readInitial();
-          const H = x ? Q(x.view()) : null;
+          const H = v ? tt(v.view()) : null;
           H == null || H.readInitial();
           let _ = 0, P = 0;
-          const $ = et(
+          const $ = nt(
             r.view().el()
           );
           $ instanceof Window ? (_ = $.scrollY, P = $.scrollX) : (_ = $.scrollTop, P = $.scrollLeft), o.eventHandlers().onSwap({
@@ -612,25 +626,25 @@ function kt(t, e) {
             fromSlot: A.id(),
             toSlot: p.id(),
             draggingItem: r.id(),
-            swappedWithItem: (x == null ? void 0 : x.id()) || ""
+            swappedWithItem: (v == null ? void 0 : v.id()) || ""
           }), requestAnimationFrame(() => {
             const N = t.querySelectorAll("[data-swapy-item]");
-            o.items().forEach((m) => {
-              const B = Array.from(N).find(
-                (L) => L.dataset.swapyItem === m.id()
+            o.items().forEach((q) => {
+              const m = Array.from(N).find(
+                (B) => B.dataset.swapyItem === q.id()
               );
-              m.view().updateElement(B);
-            }), o.syncSlotItemMap(), D.readFinalAndReverse(), H == null || H.readFinalAndReverse(), tt(r, D), x && H && tt(x, H), $.scrollTo({
+              q.view().updateElement(m);
+            }), o.syncSlotItemMap(), D.readFinalAndReverse(), H == null || H.readFinalAndReverse(), et(r, D), v && H && et(v, H), $.scrollTo({
               left: P,
               top: _
             });
           });
         } else {
           let X = 0, M = 0;
-          const D = et(
+          const D = nt(
             r.view().el()
           );
-          D instanceof Window ? (X = D.scrollY, M = D.scrollX) : (X = D.scrollTop, M = D.scrollLeft), ft(r, p, !0), x && ft(x, A), D.scrollTo({
+          D instanceof Window ? (X = D.scrollY, M = D.scrollX) : (X = D.scrollTop, M = D.scrollLeft), ut(r, p, !0), v && ut(v, A), D.scrollTo({
             left: M,
             top: X
           });
@@ -643,7 +657,7 @@ function kt(t, e) {
             fromSlot: A.id(),
             toSlot: p.id(),
             draggingItem: r.id(),
-            swappedWithItem: (x == null ? void 0 : x.id()) || ""
+            swappedWithItem: (v == null ? void 0 : v.id()) || ""
           });
         }
       }
@@ -659,19 +673,19 @@ function kt(t, e) {
       r.style.pointerEvents = "";
     }), t.style.userSelect = "", t.style.webkitUserSelect = "";
   }
-  function c(r) {
+  function f(r) {
     o.config().enabled = r;
   }
   function s(r) {
     o.eventHandlers().onSwapStart = r;
   }
-  function f(r) {
+  function u(r) {
     o.eventHandlers().onSwap = r;
   }
   function y(r) {
     o.eventHandlers().onSwapEnd = r;
   }
-  function v(r) {
+  function x(r) {
     o.eventHandlers().onBeforeSwap = r;
   }
   function g() {
@@ -683,12 +697,12 @@ function kt(t, e) {
     i.forEach((r) => r.destroy()), l.forEach((r) => r.destroy()), o.destroy(), i = [], l = [];
   }
   return {
-    enable: c,
+    enable: f,
     slotItemMap: () => o.slotItemMap(),
     onSwapStart: s,
-    onSwap: f,
+    onSwap: u,
     onSwapEnd: y,
-    onBeforeSwap: v,
+    onBeforeSwap: x,
     update: g,
     destroy: T
   };
@@ -720,36 +734,36 @@ function Ot({
     ...o
   };
   const i = (s) => {
-    var f;
-    (f = l.scrollHandler) == null || f.call(l, s);
+    var u;
+    (u = l.scrollHandler) == null || u.call(l, s);
   };
   window.addEventListener("scroll", i);
   function d(s) {
-    return l.slots.find((f) => f.id() === s);
+    return l.slots.find((u) => u.id() === s);
   }
-  function u(s) {
-    return l.items.find((f) => f.id() === s);
+  function c(s) {
+    return l.items.find((u) => u.id() === s);
   }
   function a() {
-    const s = {}, f = /* @__PURE__ */ new Map(), y = [];
-    l.slots.forEach((v) => {
+    const s = {}, u = /* @__PURE__ */ new Map(), y = [];
+    l.slots.forEach((x) => {
       var r;
-      const g = v.id(), T = ((r = v.item()) == null ? void 0 : r.id()) || "";
-      s[g] = T, f.set(g, T), y.push({ slot: g, item: T });
-    }), l.slotItemMap = { asObject: s, asMap: f, asArray: y };
+      const g = x.id(), T = ((r = x.item()) == null ? void 0 : r.id()) || "";
+      s[g] = T, u.set(g, T), y.push({ slot: g, item: T });
+    }), l.slotItemMap = { asObject: s, asMap: u, asArray: y };
   }
-  function h(s, f) {
+  function h(s, u) {
     var p;
-    const y = l.slotItemMap, v = s.id(), g = ((p = f.item()) == null ? void 0 : p.id()) || "", T = f.id(), r = s.slot().id();
-    y.asObject[T] = v, y.asObject[r] = g, y.asMap.set(T, v), y.asMap.set(r, g);
-    const I = y.asArray.findIndex(
+    const y = l.slotItemMap, x = s.id(), g = ((p = u.item()) == null ? void 0 : p.id()) || "", T = u.id(), r = s.slot().id();
+    y.asObject[T] = x, y.asObject[r] = g, y.asMap.set(T, x), y.asMap.set(r, g);
+    const E = y.asArray.findIndex(
       (w) => w.slot === T
-    ), E = y.asArray.findIndex(
+    ), I = y.asArray.findIndex(
       (w) => w.slot === r
     );
-    y.asArray[I].item = v, y.asArray[E].item = g;
+    y.asArray[E].item = x, y.asArray[I].item = g;
   }
-  function c() {
+  function f() {
     window.removeEventListener("scroll", i), l = { ...o };
   }
   return {
@@ -759,7 +773,7 @@ function Ot({
     setItems: (s) => l.items = s,
     setSlots: (s) => l.slots = s,
     slotById: d,
-    itemById: u,
+    itemById: c,
     zIndex: (s = !1) => s ? ++l.zIndexCount : l.zIndexCount,
     resetZIndex: () => {
       l.zIndexCount = 1;
@@ -771,33 +785,33 @@ function Ot({
       l.scrollHandler = s;
     },
     swapItems: h,
-    destroy: c
+    destroy: f
   };
 }
 function _t(t, e) {
-  const n = yt(t);
+  const n = wt(t);
   function o() {
     return n.el().dataset.swapySlot;
   }
   function l() {
-    const c = n.el().children[0];
-    return (c == null ? void 0 : c.dataset.swapyItem) || null;
+    const f = n.el().children[0];
+    return (f == null ? void 0 : f.dataset.swapyItem) || null;
   }
   function i() {
-    return z(n.el().getBoundingClientRect());
+    return U(n.el().getBoundingClientRect());
   }
   function d() {
-    const c = n.el().children[0];
-    if (c)
-      return e.itemById(c.dataset.swapyItem);
+    const f = n.el().children[0];
+    if (f)
+      return e.itemById(f.dataset.swapyItem);
   }
-  function u() {
-    e.slots().forEach((c) => {
-      c.view().el().removeAttribute("data-swapy-highlighted");
+  function c() {
+    e.slots().forEach((f) => {
+      f.view().el().removeAttribute("data-swapy-highlighted");
     });
   }
   function a() {
-    u(), n.el().setAttribute("data-swapy-highlighted", "");
+    c(), n.el().setAttribute("data-swapy-highlighted", "");
   }
   function h() {
   }
@@ -808,68 +822,68 @@ function _t(t, e) {
     rect: i,
     item: d,
     highlight: a,
-    unhighlightAllSlots: u,
+    unhighlightAllSlots: c,
     isHighlighted: () => n.el().hasAttribute("data-swapy-highlighted"),
     destroy: h
   };
 }
 function Pt(t, e) {
-  const n = yt(t), o = {};
-  let l = null, i = null, d = !1, u = !0, a;
+  const n = wt(t), o = {};
+  let l = null, i = null, d = !1, c = !0, a;
   const h = Nt();
-  let c = () => {
+  let f = () => {
   }, s = () => {
-  }, f = () => {
+  }, u = () => {
   }, y = () => {
   };
-  const { onDrag: v, onDrop: g, onHold: T, onRelease: r } = n.usePlugin(Mt, {
+  const { onDrag: x, onDrop: g, onHold: T, onRelease: r } = n.usePlugin(Mt, {
     startDelay: e.config().dragOnHold ? 400 : 0,
     targetEl: P()
-  }), I = R(0, 0), E = R(0, 0), p = R(0, 0), w = R(0, 0);
-  let A = null, x = null;
+  }), E = R(0, 0), I = R(0, 0), p = R(0, 0), w = R(0, 0);
+  let A = null, v = null;
   T((S) => {
-    e.config().enabled && (N() && !$(S.el) || L() && B(S.el) || f == null || f(S));
+    e.config().enabled && (N() && !$(S.el) || B() && m(S.el) || u == null || u(S));
   }), r((S) => {
-    e.config().enabled && (N() && !$(S.el) || L() && B(S.el) || y == null || y(S));
+    e.config().enabled && (N() && !$(S.el) || B() && m(S.el) || y == null || y(S));
   });
   function X(S) {
-    var q;
-    F(), K().highlight(), (q = o.drop) == null || q.call(o);
+    var F;
+    b(), J().highlight(), (F = o.drop) == null || F.call(o);
     const Y = e.slots().map((O) => O.view().boundingRect());
-    e.slots().forEach((O, W) => {
-      const j = Y[W];
-      O.view().el().style.width = `${j.width}px`, O.view().el().style.maxWidth = `${j.width}px`, O.view().el().style.flexShrink = "0", O.view().el().style.height = `${j.height}px`;
+    e.slots().forEach((O, j) => {
+      const k = Y[j];
+      O.view().el().style.width = `${k.width}px`, O.view().el().style.maxWidth = `${k.width}px`, O.view().el().style.flexShrink = "0", O.view().el().style.height = `${k.height}px`;
     });
-    const b = e.slotItemMap(!0);
+    const L = e.slotItemMap(!0);
     e.eventHandlers().onSwapStart({
-      draggingItem: nt(),
-      fromSlot: ot(),
-      slotItemMap: b
-    }), i = b, n.el().style.position = "relative", n.el().style.zIndex = `${e.zIndex(!0)}`, A = et(S.el), e.config().autoScrollOnDrag && (l = Wt(
+      draggingItem: ot(),
+      fromSlot: lt(),
+      slotItemMap: L
+    }), i = L, n.el().style.position = "relative", n.el().style.zIndex = `${e.zIndex(!0)}`, A = nt(S.el), e.config().autoScrollOnDrag && (l = Wt(
       A,
       e.config().dragAxis
     ), l.updatePointer({
       x: S.pointerX,
       y: S.pointerY
-    })), I.x = window.scrollX, I.y = window.scrollY, p.x = 0, p.y = 0, A instanceof HTMLElement && (E.x = A.scrollLeft, E.y = A.scrollTop, x = () => {
-      w.x = A.scrollLeft - E.x, w.y = A.scrollTop - E.y, n.setTransform({
+    })), E.x = window.scrollX, E.y = window.scrollY, p.x = 0, p.y = 0, A instanceof HTMLElement && (I.x = A.scrollLeft, I.y = A.scrollTop, v = () => {
+      w.x = A.scrollLeft - I.x, w.y = A.scrollTop - I.y, n.setTransform({
         dragX: ((a == null ? void 0 : a.width) || 0) + p.x + w.x,
         dragY: ((a == null ? void 0 : a.height) || 0) + p.y + w.y
       });
-    }, A.addEventListener("scroll", x)), e.onScroll(() => {
-      p.x = window.scrollX - I.x, p.y = window.scrollY - I.y;
-      const O = w.x || 0, W = w.y || 0;
+    }, A.addEventListener("scroll", v)), e.onScroll(() => {
+      p.x = window.scrollX - E.x, p.y = window.scrollY - E.y;
+      const O = w.x || 0, j = w.y || 0;
       n.setTransform({
         dragX: ((a == null ? void 0 : a.width) || 0) + p.x + O,
-        dragY: ((a == null ? void 0 : a.height) || 0) + p.y + W
+        dragY: ((a == null ? void 0 : a.height) || 0) + p.y + j
       });
     });
   }
-  v((S) => {
+  x((S) => {
     var Y;
     if (e.config().enabled) {
       if (!d) {
-        if (N() && !$(S.el) || L() && B(S.el))
+        if (N() && !$(S.el) || B() && m(S.el))
           return;
         X(S);
       }
@@ -878,55 +892,55 @@ function Pt(t, e) {
         y: S.pointerY
       }), a = S, (Y = o.drop) == null || Y.call(o), h(() => {
         n.el().style.position = "relative";
-        const b = S.width + p.x + w.x, q = S.height + p.y + w.y;
+        const L = S.width + p.x + w.x, F = S.height + p.y + w.y;
         e.config().dragAxis === "y" ? n.setTransform({
-          dragY: q
+          dragY: F
         }) : e.config().dragAxis === "x" ? n.setTransform({
-          dragX: b
+          dragX: L
         }) : n.setTransform({
-          dragX: b,
-          dragY: q
-        }), c == null || c(S);
+          dragX: L,
+          dragY: F
+        }), f == null || f(S);
       });
     }
   }), g((S) => {
     if (!d) return;
-    Z(), d = !1, u = !1, a = null, A && (A.removeEventListener("scroll", x), x = null), A = null, w.x = 0, w.y = 0, p.x = 0, p.y = 0, l && (l.destroy(), l = null), K().unhighlightAllSlots(), s == null || s(S), e.eventHandlers().onSwapEnd({
+    W(), d = !1, c = !1, a = null, A && (A.removeEventListener("scroll", v), v = null), A = null, w.x = 0, w.y = 0, p.x = 0, p.y = 0, l && (l.destroy(), l = null), J().unhighlightAllSlots(), s == null || s(S), e.eventHandlers().onSwapEnd({
       slotItemMap: e.slotItemMap(),
       hasChanged: i != null && i.asMap ? !Ft(
         i == null ? void 0 : i.asMap,
         e.slotItemMap().asMap
       ) : !1
-    }), i = null, e.onScroll(null), e.slots().forEach((b) => {
-      b.view().el().style.width = "", b.view().el().style.maxWidth = "", b.view().el().style.flexShrink = "", b.view().el().style.height = "";
+    }), i = null, e.onScroll(null), e.slots().forEach((L) => {
+      L.view().el().style.width = "", L.view().el().style.maxWidth = "", L.view().el().style.flexShrink = "", L.view().el().style.height = "";
     }), e.config().manualSwap && e.config().swapMode === "drop" ? requestAnimationFrame(Y) : Y();
     function Y() {
-      const b = n.currentTransform(), q = b.dragX + b.translateX, O = b.dragY + b.translateY;
-      o.drop = mt(
-        { translate: R(q, O) },
+      const L = n.currentTransform(), F = L.dragX + L.translateX, O = L.dragY + L.translateY;
+      o.drop = yt(
+        { translate: R(F, O) },
         { translate: R(0, 0) },
-        ({ translate: W }, j) => {
-          j ? d || (n.clearTransform(), n.el().style.transformOrigin = "") : n.setTransform({
+        ({ translate: j }, k) => {
+          k ? d || (n.clearTransform(), n.el().style.transformOrigin = "") : n.setTransform({
             dragX: 0,
             dragY: 0,
-            translateX: W.x,
-            translateY: W.y
-          }), j && (e.items().forEach((lt) => {
-            lt.isDragging() || (lt.view().el().style.zIndex = "");
-          }), e.resetZIndex(), n.el().style.position = "", u = !0);
+            translateX: j.x,
+            translateY: j.y
+          }), k && (e.items().forEach((rt) => {
+            rt.isDragging() || (rt.view().el().style.zIndex = "");
+          }), e.resetZIndex(), n.el().style.position = "", c = !0);
         },
-        wt(e.config().animation)
+        St(e.config().animation)
       );
     }
   });
   function M(S) {
-    c = S;
+    f = S;
   }
   function D(S) {
     s = S;
   }
   function H(S) {
-    f = S;
+    u = S;
   }
   function _(S) {
     y = S;
@@ -941,53 +955,53 @@ function Pt(t, e) {
   function N() {
     return P() !== null;
   }
-  function m() {
+  function q() {
     return Array.from(n.el().querySelectorAll("[data-swapy-no-drag]"));
   }
-  function B(S) {
-    const Y = m();
-    return !Y || Y.length === 0 ? !1 : Y.includes(S) || Y.some((b) => b.contains(S));
+  function m(S) {
+    const Y = q();
+    return !Y || Y.length === 0 ? !1 : Y.includes(S) || Y.some((L) => L.contains(S));
   }
-  function L() {
-    return m().length > 0;
+  function B() {
+    return q().length > 0;
   }
-  function F() {
+  function b() {
     n.el().setAttribute("data-swapy-dragging", "");
   }
-  function Z() {
+  function W() {
     n.el().removeAttribute("data-swapy-dragging");
   }
-  function St() {
-    c = null, s = null, f = null, y = null, a = null, i = null, l && (l.destroy(), l = null), A && x && A.removeEventListener("scroll", x), n.destroy();
+  function K() {
+    f = null, s = null, u = null, y = null, a = null, i = null, l && (l.destroy(), l = null), A && v && A.removeEventListener("scroll", v), n.destroy();
   }
-  function nt() {
+  function ot() {
     return n.el().dataset.swapyItem;
   }
-  function K() {
+  function J() {
     return e.slotById(n.el().parentElement.dataset.swapySlot);
   }
-  function ot() {
+  function lt() {
     return n.el().parentElement.dataset.swapySlot;
   }
   return {
-    id: nt,
+    id: ot,
     view: () => n,
-    slot: K,
-    slotId: ot,
+    slot: J,
+    slotId: lt,
     onDrag: M,
     onDrop: D,
     onHold: H,
     onRelease: _,
-    destroy: St,
+    destroy: K,
     isDragging: () => d,
     cancelAnimation: () => o,
     dragEvent: () => a,
     store: () => e,
-    continuousDrag: () => u,
-    setContinuousDrag: (S) => u = S
+    continuousDrag: () => c,
+    setContinuousDrag: (S) => c = S
   };
 }
-function ft(t, e, n = !1) {
+function ut(t, e, n = !1) {
   if (n) {
     const l = e.item();
     l && (e.view().el().style.position = "relative", l.view().el().style.position = "absolute");
@@ -997,8 +1011,8 @@ function ft(t, e, n = !1) {
   }
   if (!t)
     return;
-  const o = Q(t.view());
-  o.readInitial(), e.view().el().appendChild(t.view().el()), o.readFinalAndReverse(), tt(t, o);
+  const o = tt(t.view());
+  o.readInitial(), e.view().el().appendChild(t.view().el()), o.readFinalAndReverse(), et(t, o);
 }
 function Nt() {
   let t = !1;
@@ -1008,12 +1022,12 @@ function Nt() {
     }));
   };
 }
-function tt(t, e) {
-  var u, a, h, c;
-  (a = (u = t.cancelAnimation()).moveToSlot) == null || a.call(u), (c = (h = t.cancelAnimation()).drop) == null || c.call(h);
-  const n = wt(t.store().config().animation), o = e.transitionValues();
+function et(t, e) {
+  var c, a, h, f;
+  (a = (c = t.cancelAnimation()).moveToSlot) == null || a.call(c), (f = (h = t.cancelAnimation()).drop) == null || f.call(h);
+  const n = St(t.store().config().animation), o = e.transitionValues();
   let l = t.view().currentTransform(), i = 0, d = !1;
-  t.cancelAnimation().moveToSlot = mt(
+  t.cancelAnimation().moveToSlot = yt(
     {
       translate: o.from.translate,
       scale: o.from.scale,
@@ -1024,10 +1038,10 @@ function tt(t, e) {
       scale: o.to.scale,
       borderRadius: o.to.borderRadius
     },
-    ({ translate: s, scale: f, borderRadius: y }, v, g) => {
+    ({ translate: s, scale: u, borderRadius: y }, x, g) => {
       if (t.isDragging()) {
         i !== 0 && (d = !0);
-        const r = t.dragEvent().relativeX, I = t.dragEvent().relativeY;
+        const r = t.dragEvent().relativeX, E = t.dragEvent().relativeY;
         t.continuousDrag() ? t.view().setTransform({
           translateX: C(
             l.translateX,
@@ -1036,35 +1050,35 @@ function tt(t, e) {
           ),
           translateY: C(
             l.translateY,
-            l.translateY + (o.from.height - o.to.height) * I,
+            l.translateY + (o.from.height - o.to.height) * E,
             n.easing(g - i)
           ),
-          scaleX: f.x,
-          scaleY: f.y
-        }) : t.view().setTransform({ scaleX: f.x, scaleY: f.y });
+          scaleX: u.x,
+          scaleY: u.y
+        }) : t.view().setTransform({ scaleX: u.x, scaleY: u.y });
       } else
         l = t.view().currentTransform(), i = g, d ? t.view().setTransform({
-          scaleX: f.x,
-          scaleY: f.y
+          scaleX: u.x,
+          scaleY: u.y
         }) : t.view().setTransform({
           dragX: 0,
           dragY: 0,
           translateX: s.x,
           translateY: s.y,
-          scaleX: f.x,
-          scaleY: f.y
+          scaleX: u.x,
+          scaleY: u.y
         });
       const T = e.childrenTransitionData();
       T.forEach(
         ({
           el: r,
-          fromTranslate: I,
-          fromScale: E,
+          fromTranslate: E,
+          fromScale: I,
           fromBorderRadius: p,
           toBorderRadius: w,
           parentScale: A
         }) => {
-          const x = C(
+          const v = C(
             A.x,
             1,
             n.easing(g)
@@ -1073,69 +1087,69 @@ function tt(t, e) {
             1,
             n.easing(g)
           );
-          r.style.transform = `translate(${I.x + (0 - I.x / x) * n.easing(g)}px, ${I.y + (0 - I.y / X) * n.easing(g)}px) scale(${C(
-            E.x / x,
-            1 / x,
+          r.style.transform = `translate(${E.x + (0 - E.x / v) * n.easing(g)}px, ${E.y + (0 - E.y / X) * n.easing(g)}px) scale(${C(
+            I.x / v,
+            1 / v,
             n.easing(g)
           )}, ${C(
-            E.y / X,
+            I.y / X,
             1 / X,
             n.easing(g)
-          )})`, it(p) || (r.style.borderRadius = G(
-            pt(
+          )})`, at(p) || (r.style.borderRadius = Z(
+            mt(
               p,
               w,
               n.easing(g)
             )
           ));
         }
-      ), it(y) || (t.view().el().style.borderRadius = G(y)), v && (t.isDragging() || (t.view().el().style.transformOrigin = "", t.view().clearTransform()), t.view().el().style.borderRadius = "", T.forEach(({ el: r }) => {
+      ), at(y) || (t.view().el().style.borderRadius = Z(y)), x && (t.isDragging() || (t.view().el().style.transformOrigin = "", t.view().clearTransform()), t.view().el().style.borderRadius = "", T.forEach(({ el: r }) => {
         r.style.transform = "", r.style.transformOrigin = "", r.style.borderRadius = "";
       }));
     },
     n
   );
 }
-function k(...t) {
+function V(...t) {
   console.error("Swapy Error:", ...t);
 }
 function qt(t) {
   const e = t;
   let n = !0;
   const o = e.querySelectorAll("[data-swapy-slot]");
-  e || (k("container passed to createSwapy() is undefined or null"), n = !1), o.forEach((u) => {
-    const a = u, h = a.dataset.swapySlot, c = a.children, s = c[0];
-    (!h || h.length === 0) && (k(a, "does not contain a slotId using data-swapy-slot"), n = !1), c.length > 1 && (k("slot:", `"${h}"`, "cannot contain more than one element"), n = !1), s && (!s.dataset.swapyItem || s.dataset.swapyItem.length === 0) && (k(
+  e || (V("container passed to createSwapy() is undefined or null"), n = !1), o.forEach((c) => {
+    const a = c, h = a.dataset.swapySlot, f = a.children, s = f[0];
+    (!h || h.length === 0) && (V(a, "does not contain a slotId using data-swapy-slot"), n = !1), f.length > 1 && (V("slot:", `"${h}"`, "cannot contain more than one element"), n = !1), s && (!s.dataset.swapyItem || s.dataset.swapyItem.length === 0) && (V(
       "slot",
       `"${h}"`,
       "does not contain an element with an item id using data-swapy-item"
     ), n = !1);
   });
   const l = Array.from(o).map(
-    (u) => u.dataset.swapySlot
+    (c) => c.dataset.swapySlot
   ), i = e.querySelectorAll("[data-swapy-item]"), d = Array.from(i).map(
-    (u) => u.dataset.swapyItem
+    (c) => c.dataset.swapyItem
   );
-  if (ut(l)) {
-    const u = dt(l);
-    k(
+  if (dt(l)) {
+    const c = gt(l);
+    V(
       "your container has duplicate slot ids",
-      `(${u.join(", ")})`
+      `(${c.join(", ")})`
     ), n = !1;
   }
-  if (ut(d)) {
-    const u = dt(d);
-    k(
+  if (dt(d)) {
+    const c = gt(d);
+    V(
       "your container has duplicate item ids",
-      `(${u.join(", ")})`
+      `(${c.join(", ")})`
     ), n = !1;
   }
   return n;
 }
-function ut(t) {
+function dt(t) {
   return new Set(t).size !== t.length;
 }
-function dt(t) {
+function gt(t) {
   const e = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
   for (const o of t)
     e.has(o) ? n.add(o) : e.add(o);
@@ -1147,7 +1161,7 @@ function Ft(t, e) {
     if (e.get(n) !== o) return !1;
   return !0;
 }
-function et(t) {
+function nt(t) {
   let e = t;
   for (; e; ) {
     const n = window.getComputedStyle(e), o = n.overflowY, l = n.overflowX;
@@ -1158,62 +1172,62 @@ function et(t) {
   return window;
 }
 function Wt(t, e) {
-  let l = !1, i, d = 0, u = 0, a = 0, h = 0, c = 0, s = 0, f = null;
-  t instanceof HTMLElement ? (i = z(t.getBoundingClientRect()), d = t.scrollHeight - i.height, u = t.scrollWidth - i.width) : (i = {
+  let l = !1, i, d = 0, c = 0, a = 0, h = 0, f = 0, s = 0, u = null;
+  t instanceof HTMLElement ? (i = U(t.getBoundingClientRect()), d = t.scrollHeight - i.height, c = t.scrollWidth - i.width) : (i = {
     x: 0,
     y: 0,
     width: window.innerWidth,
     height: window.innerHeight
-  }, d = document.documentElement.scrollHeight - window.innerHeight, u = document.documentElement.scrollWidth - window.innerWidth);
+  }, d = document.documentElement.scrollHeight - window.innerHeight, c = document.documentElement.scrollWidth - window.innerWidth);
   function y() {
     t instanceof HTMLElement ? (a = t.scrollTop, h = t.scrollLeft) : (a = window.scrollY, h = window.scrollX);
   }
-  function v(r) {
+  function x(r) {
     l = !1;
-    const I = i.y, E = i.y + i.height, p = i.x, w = i.x + i.width, A = Math.abs(I - r.y) < Math.abs(E - r.y), x = Math.abs(p - r.x) < Math.abs(w - r.x);
+    const E = i.y, I = i.y + i.height, p = i.x, w = i.x + i.width, A = Math.abs(E - r.y) < Math.abs(I - r.y), v = Math.abs(p - r.x) < Math.abs(w - r.x);
     if (y(), e !== "x")
       if (A) {
-        const X = I - r.y;
+        const X = E - r.y;
         if (X >= -100) {
-          const M = V(X, -100, 0);
-          c = -U(-100, 0, 0, 5, M), l = !0;
+          const M = z(X, -100, 0);
+          f = -G(-100, 0, 0, 5, M), l = !0;
         }
       } else {
-        const X = E - r.y;
+        const X = I - r.y;
         if (X <= 100) {
-          const M = V(X, 0, 100);
-          c = U(100, 0, 0, 5, M), l = !0;
+          const M = z(X, 0, 100);
+          f = G(100, 0, 0, 5, M), l = !0;
         }
       }
     if (e !== "y")
-      if (x) {
+      if (v) {
         const X = p - r.x;
         if (X >= -100) {
-          const M = V(X, -100, 0);
-          s = -U(-100, 0, 0, 5, M), l = !0;
+          const M = z(X, -100, 0);
+          s = -G(-100, 0, 0, 5, M), l = !0;
         }
       } else {
         const X = w - r.x;
         if (X <= 100) {
-          const M = V(X, 0, 100);
-          s = U(100, 0, 0, 5, M), l = !0;
+          const M = z(X, 0, 100);
+          s = G(100, 0, 0, 5, M), l = !0;
         }
       }
-    l && (f && cancelAnimationFrame(f), g());
+    l && (u && cancelAnimationFrame(u), g());
   }
   function g() {
-    y(), e !== "x" && (c = a + c >= d ? 0 : c), e !== "y" && (s = h + s >= u ? 0 : s), t.scrollBy({ top: c, left: s }), l && (f = requestAnimationFrame(g));
+    y(), e !== "x" && (f = a + f >= d ? 0 : f), e !== "y" && (s = h + s >= c ? 0 : s), t.scrollBy({ top: f, left: s }), l && (u = requestAnimationFrame(g));
   }
   function T() {
     l = !1;
   }
   return {
-    updatePointer: v,
+    updatePointer: x,
     destroy: T
   };
 }
 export {
   kt as createSwapy,
-  et as getClosestScrollableContainer,
+  nt as getClosestScrollableContainer,
   jt as utils
 };
diff --git a/dist/swapy.min.js b/dist/swapy.min.js
index 4b554341f44305bc08a569d33186552c5301104d..a95327307ebe13e1b9875bcff31c503dd2258dae 100644
--- a/dist/swapy.min.js
+++ b/dist/swapy.min.js
@@ -1,5 +1,5 @@
-(function(N,j){typeof exports=="object"&&typeof module<"u"?j(exports):typeof define=="function"&&define.amd?define(["exports"],j):(N=typeof globalThis<"u"?globalThis:N||self,j(N.Swapy={}))})(this,function(N){"use strict";function j(t){return typeof t=="object"&&t!==null&&"x"in t&&"y"in t&&"unit"in t&&typeof t.unit=="string"&&typeof t.x=="object"&&typeof t.y=="object"&&"topLeft"in t.x&&"topRight"in t.x&&"bottomRight"in t.x&&"bottomLeft"in t.x&&"topLeft"in t.y&&"topRight"in t.y&&"bottomRight"in t.y&&"bottomLeft"in t.y}function lt(t){var h;const e=t.match(/(\d+(?:\.\d+)?)(px|%)/g);if(!e)return{x:{topLeft:0,topRight:0,bottomRight:0,bottomLeft:0},y:{topLeft:0,topRight:0,bottomRight:0,bottomLeft:0},unit:"px"};const n=e.map(c=>{const[s,f,m]=c.match(/(\d+(?:\.\d+)?)(px|%)/)??[];return{value:parseFloat(f),unit:m}}),o=((h=n[0])==null?void 0:h.unit)||"px";if(n.some(c=>c.unit!==o))throw new Error("Inconsistent units in border-radius string.");const[l,i,d,u]=n.map(c=>c.value),a={topLeft:l??0,topRight:i??l??0,bottomRight:d??l??0,bottomLeft:u??i??l??0};return{x:{...a},y:{...a},unit:o}}function rt({x:t,y:e,unit:n},o,l){if(n==="px"){const i={topLeft:t.topLeft/o,topRight:t.topRight/o,bottomLeft:t.bottomLeft/o,bottomRight:t.bottomRight/o},d={topLeft:e.topLeft/l,topRight:e.topRight/l,bottomLeft:e.bottomLeft/l,bottomRight:e.bottomRight/l};return{x:i,y:d,unit:"px"}}else if(n==="%")return{x:t,y:e,unit:"%"};return{x:t,y:e,unit:n}}function Z(t){return`
+(function(N,W){typeof exports=="object"&&typeof module<"u"?W(exports):typeof define=="function"&&define.amd?define(["exports"],W):(N=typeof globalThis<"u"?globalThis:N||self,W(N.Swapy={}))})(this,function(N){"use strict";function W(t){return typeof t=="object"&&t!==null&&"x"in t&&"y"in t&&"unit"in t&&typeof t.unit=="string"&&typeof t.x=="object"&&typeof t.y=="object"&&"topLeft"in t.x&&"topRight"in t.x&&"bottomRight"in t.x&&"bottomLeft"in t.x&&"topLeft"in t.y&&"topRight"in t.y&&"bottomRight"in t.y&&"bottomLeft"in t.y}function rt(t){var h;const e=t.match(/(\d+(?:\.\d+)?)(px|%)/g);if(!e)return{x:{topLeft:0,topRight:0,bottomRight:0,bottomLeft:0},y:{topLeft:0,topRight:0,bottomRight:0,bottomLeft:0},unit:"px"};const n=e.map(f=>{const[s,u,m]=f.match(/(\d+(?:\.\d+)?)(px|%)/)??[];return{value:parseFloat(u),unit:m}}),o=((h=n[0])==null?void 0:h.unit)||"px";if(n.some(f=>f.unit!==o))throw new Error("Inconsistent units in border-radius string.");const[l,i,d,c]=n.map(f=>f.value),a={topLeft:l??0,topRight:i??l??0,bottomRight:d??l??0,bottomLeft:c??i??l??0};return{x:{...a},y:{...a},unit:o}}function it({x:t,y:e,unit:n},o,l){if(n==="px"){const i={topLeft:t.topLeft/o,topRight:t.topRight/o,bottomLeft:t.bottomLeft/o,bottomRight:t.bottomRight/o},d={topLeft:e.topLeft/l,topRight:e.topRight/l,bottomLeft:e.bottomLeft/l,bottomRight:e.bottomRight/l};return{x:i,y:d,unit:"px"}}else if(n==="%")return{x:t,y:e,unit:"%"};return{x:t,y:e,unit:n}}function K(t){return`
     ${t.x.topLeft}${t.unit} ${t.x.topRight}${t.unit} ${t.x.bottomRight}${t.unit} ${t.x.bottomLeft}${t.unit}
     /
     ${t.y.topLeft}${t.unit} ${t.y.topRight}${t.unit} ${t.y.bottomRight}${t.unit} ${t.y.bottomLeft}${t.unit}
-  `}function it(t){return t.x.topLeft===0&&t.x.topRight===0&&t.x.bottomRight===0&&t.x.bottomLeft===0&&t.y.topLeft===0&&t.y.topRight===0&&t.y.bottomRight===0&&t.y.bottomLeft===0}function at(t){return typeof t=="object"&&"x"in t&&"y"in t}function R(t,e){return{x:t,y:e}}function xt(t,e){return R(t.x+e.x,t.y+e.y)}function vt(t,e){return R(t.x-e.x,t.y-e.y)}function It(t,e){return R(t.x*e,t.y*e)}function L(t,e,n){return t+(e-t)*n}function At(t,e,n){return xt(t,It(vt(e,t),n))}function st(t,e,n){return{x:{topLeft:L(t.x.topLeft,e.x.topLeft,n),topRight:L(t.x.topRight,e.x.topRight,n),bottomRight:L(t.x.bottomRight,e.x.bottomRight,n),bottomLeft:L(t.x.bottomLeft,e.x.bottomLeft,n)},y:{topLeft:L(t.y.topLeft,e.y.topLeft,n),topRight:L(t.y.topRight,e.y.topRight,n),bottomRight:L(t.y.bottomRight,e.y.bottomRight,n),bottomLeft:L(t.y.bottomLeft,e.y.bottomLeft,n)},unit:t.unit}}function Et(t,e,n){return W((n-t)/(e-t),0,1)}function K(t,e,n,o,l){return L(n,o,Et(t,e,l))}function W(t,e,n){return Math.min(Math.max(t,e),n)}const Tt={duration:350,easing:t=>t};function ct(t,e,n,o){let l=!1;const i=()=>{l=!0},d={...Tt,...o};let u;function a(h){u===void 0&&(u=h);const c=h-u,s=W(c/d.duration,0,1),f=Object.keys(t),m=Object.keys(e);if(!f.every(g=>m.includes(g))){console.error("animate Error: `from` keys are different than `to`");return}const v={};f.forEach(g=>{typeof t[g]=="number"&&typeof e[g]=="number"?v[g]=L(t[g],e[g],d.easing(s)):j(t[g])&&j(e[g])?v[g]=st(t[g],e[g],d.easing(s)):at(t[g])&&at(e[g])&&(v[g]=At(t[g],e[g],d.easing(s)))}),n(v,s>=1,s),s<1&&!l&&requestAnimationFrame(a)}return requestAnimationFrame(a),i}const Xt={startDelay:0,targetEl:null};function Mt(t,e){const n={...Xt,...e};let o=t.el(),l=!1,i=null,d=null,u=null,a=null,h=0,c=0,s=0,f=0,m=0,v=0,g=0,X=0,r=0,I=0,E=null,p;o.addEventListener("pointerdown",w),document.body.addEventListener("pointerup",x),document.body.addEventListener("pointermove",T),document.body.addEventListener("touchmove",M,{passive:!1});function w(y){if(n.targetEl&&y.target!==n.targetEl&&!n.targetEl.contains(y.target)||l||!y.isPrimary)return;n.startDelay>0?(u==null||u({el:y.target}),p=setTimeout(()=>{B()},n.startDelay)):B();function B(){E=y.target;const C=t.boundingRect(),V=t.layoutRect();m=V.x,v=V.y,s=C.x-m,f=C.y-v,h=y.clientX-s,c=y.clientY-f,g=y.clientX,X=y.clientY,r=(y.clientX-C.x)/C.width,I=(y.clientY-C.y)/C.height,l=!0,T(y)}}function A(){const y=t.layoutRect();h-=m-y.x,c-=v-y.y,m=y.x,v=y.y}function x(y){if(!l){p&&(clearTimeout(p),p=null,a==null||a({el:y.target}));return}if(!y.isPrimary)return;l=!1;const B=y.clientX-g,C=y.clientY-X;d==null||d({x:s,y:f,pointerX:y.clientX,pointerY:y.clientY,width:B,height:C,relativeX:r,relativeY:I,el:E}),E=null}function T(y){if(!l){p&&(clearTimeout(p),p=null,a==null||a({el:y.target}));return}if(!y.isPrimary)return;const B=y.clientX-g,C=y.clientY-X,V=s=y.clientX-h,nt=f=y.clientY-c;i==null||i({width:B,height:C,x:V,y:nt,pointerX:y.clientX,pointerY:y.clientY,relativeX:r,relativeY:I,el:E})}function M(y){if(!l)return!0;y.preventDefault()}function b(y){i=y}function H(y){d=y}function _(y){u=y}function P(y){a=y}function $(){o.removeEventListener("pointerdown",w),o=t.el(),o.addEventListener("pointerdown",w)}function q(){t.el().removeEventListener("pointerdown",w),document.body.removeEventListener("pointerup",x),document.body.removeEventListener("pointermove",T),document.body.removeEventListener("touchmove",M),i=null,d=null,u=null,a=null}return{onDrag:b,onDrop:H,onHold:_,onRelease:P,onElementUpdate:$,destroy:q,readjust:A}}function bt(t){return 1+2.70158*Math.pow(t-1,3)+1.70158*Math.pow(t-1,2)}function Dt(t){return 1-Math.pow(1-t,3)}function G(t){return{x:t.x,y:t.y,width:t.width,height:t.height}}function Lt(t){const e=t.getBoundingClientRect();let n=0,o=0,l=t.parentElement;for(;l;){const d=getComputedStyle(l).transform;if(d&&d!=="none"){const u=d.match(/matrix.*\((.+)\)/);if(u){const a=u[1].split(", ").map(Number);n+=a[4]||0,o+=a[5]||0}}l=l.parentElement}return{y:e.top-o,x:e.left-n,width:e.width,height:e.height}}function Q(t){let e=t,n=0,o=0;for(;e;)n+=e.offsetTop,o+=e.offsetLeft,e=e.offsetParent;return{x:o,y:n,width:t.offsetWidth,height:t.offsetHeight}}function ft(t,e){return t.x>=e.x&&t.x<=e.x+e.width&&t.y>=e.y&&t.y<=e.y+e.height}function Ct(t){let e=t,n=0,o=0;for(;e;){const l=i=>{const d=getComputedStyle(i);return/(auto|scroll)/.test(d.overflow+d.overflowY+d.overflowX)};if(e===document.body){o+=window.scrollX,n+=window.scrollY;break}l(e)&&(o+=e.scrollLeft,n+=e.scrollTop),e=e.parentElement}return{x:o,y:n}}function tt(t){let e="unread",n,o,l,i,d,u,a,h,c,s,f;function m(){n=t.currentTransform(),o=Lt(t.el()),l=Ct(t.el()),f=ut(t.el()).map(({parent:I,children:E})=>({parent:{el:I,initialRect:G(I.getBoundingClientRect())},children:E.filter(p=>p instanceof HTMLElement).map(p=>{const w=p;return w.originalBorderRadius||(w.originalBorderRadius=getComputedStyle(p).borderRadius),{el:p,borderRadius:lt(w.originalBorderRadius),initialRect:G(p.getBoundingClientRect())}})})),e="readInitial"}function v(){if(e!=="readInitial")throw new Error("FlipView: Cannot read final values before reading initial values");c=t.layoutRect(),u=o.width/c.width,a=o.height/c.height,i=o.x-c.x-n.dragX+l.x,d=o.y-c.y-n.dragY+l.y,h=rt(t.borderRadius(),u,a);const r=ut(t.el());f=f.map(({parent:E,children:p},w)=>{const A=r[w].parent;return{parent:{...E,el:A,finalRect:Q(A)},children:p.map((x,T)=>{const M=r[w].children[T];let b=Q(M);return M.hasAttribute("data-swapy-text")&&(b={...b,width:x.initialRect.width,height:x.initialRect.height}),{...x,el:M,finalRect:b}})}});const I={translateX:i,translateY:d,scaleX:u,scaleY:a};t.el().style.transformOrigin="0 0",t.el().style.borderRadius=Z(h),t.setTransform(I),s=[],f.forEach(({parent:E,children:p})=>{const w=p.map(({el:A,initialRect:x,finalRect:T,borderRadius:M})=>Yt(A,x,T,M,E.initialRect,E.finalRect));s.push(...w)}),e="readFinal"}function g(){if(e!=="readFinal")throw new Error("FlipView: Cannot get transition values before reading");return{from:{width:o.width,height:o.height,translate:R(i,d),scale:R(u,a),borderRadius:h},to:{width:c.width,height:c.height,translate:R(0,0),scale:R(1,1),borderRadius:t.borderRadius()}}}function X(){if(e!=="readFinal")throw new Error("FlipView: Cannot get children transition values before reading");return s}return{readInitial:m,readFinalAndReverse:v,transitionValues:g,childrenTransitionData:X}}function Yt(t,e,n,o,l,i){t.style.transformOrigin="0 0";const d=l.width/i.width,u=l.height/i.height,a=e.width/n.width,h=e.height/n.height,c=rt(o,a,h),s=e.x-l.x,f=n.x-i.x,m=e.y-l.y,v=n.y-i.y,g=(s-f*d)/d,X=(m-v*u)/u;return t.style.transform=`translate(${g}px, ${X}px) scale(${a/d}, ${h/u})`,t.style.borderRadius=Z(c),{el:t,fromTranslate:R(g,X),fromScale:R(a,h),fromBorderRadius:c,toBorderRadius:o,parentScale:{x:d,y:u}}}function ut(t){const e=[];function n(o){const l=Array.from(o.children).filter(i=>i instanceof HTMLElement);l.length>0&&(e.push({parent:o,children:l}),l.forEach(i=>n(i)))}return n(t),e}function dt(t){const e=[];let n=t,o={dragX:0,dragY:0,translateX:0,translateY:0,scaleX:1,scaleY:1};const l=lt(window.getComputedStyle(n).borderRadius),i={el:()=>n,setTransform:d,clearTransform:u,currentTransform:()=>o,borderRadius:()=>l,layoutRect:()=>Q(n),boundingRect:()=>G(n.getBoundingClientRect()),usePlugin:h,destroy:c,updateElement:s};function d(f){o={...o,...f},a()}function u(){o={dragX:0,dragY:0,translateX:0,translateY:0,scaleX:1,scaleY:1},a()}function a(){const{dragX:f,dragY:m,translateX:v,translateY:g,scaleX:X,scaleY:r}=o;f===0&&m===0&&v===0&&g===0&&X===1&&r===1?n.style.transform="":n.style.transform=`translate(${f+v}px, ${m+g}px) scale(${X}, ${r})`}function h(f,m){const v=f(i,m);return e.push(v),v}function c(){e.forEach(f=>f.destroy())}function s(f){if(!f)return;const m=n.hasAttribute("data-swapy-dragging"),v=n.style.cssText;n=f,m&&n.setAttribute("data-swapy-dragging",""),n.style.cssText=v,e.forEach(g=>g.onElementUpdate())}return i}function Rt(t,e,n){return n.map(o=>({slotId:o.slot,itemId:o.item,item:o.item===""?null:t.find(l=>o.item===l[e])}))}function Ht(t,e){return t.map(n=>({item:n[e],slot:n[e]}))}function $t(t,e,n,o,l,i=!1){const d=e.filter(h=>!o.some(c=>c.item===h[n])).map(h=>({slot:h[n],item:h[n]}));let u;i?u=o.map(h=>e.some(c=>c[n]===h.item)?h:{slot:h.slot,item:""}):u=o.filter(h=>e.some(c=>c[n]===h.item)||!h.item);const a=[...u,...d];l(a),(d.length>0||u.length!==o.length)&&requestAnimationFrame(()=>{t==null||t.update()})}const Bt=Object.freeze(Object.defineProperty({__proto__:null,dynamicSwapy:$t,initSlotItemMap:Ht,toSlottedItems:Rt},Symbol.toStringTag,{value:"Module"})),Ot={animation:"dynamic",enabled:!0,swapMode:"hover",dragOnHold:!1,autoScrollOnDrag:!1,dragAxis:"both",manualSwap:!1};function gt(t){switch(t){case"dynamic":return{easing:Dt,duration:300};case"spring":return{easing:bt,duration:350};case"none":return{easing:e=>e,duration:1}}}function _t(t,e){const n={...Ot,...e},o=Pt({slots:[],items:[],config:n});let l=[],i=[];d();function d(){if(!jt(t))throw new Error("Cannot create a Swapy instance because your HTML structure is invalid. Fix all above errors and then try!");l=Array.from(t.querySelectorAll("[data-swapy-slot]")).map(r=>Nt(r,o)),o.setSlots(l),i=Array.from(t.querySelectorAll("[data-swapy-item]")).map(r=>qt(r,o)),o.setItems(i),o.syncSlotItemMap(),i.forEach(r=>{r.onDrag(({pointerX:I,pointerY:E})=>{a();let p=!1;l.forEach(w=>{const A=w.rect();ft({x:I,y:E},A)&&(p=!0,w.isHighlighted()||w.highlight())}),!p&&o.config().swapMode==="drop"&&r.slot().highlight(),n.swapMode==="hover"&&u(r,{pointerX:I,pointerY:E})}),r.onDrop(({pointerX:I,pointerY:E})=>{h(),n.swapMode==="drop"&&u(r,{pointerX:I,pointerY:E})}),r.onHold(()=>{a()}),r.onRelease(()=>{h()})})}function u(r,{pointerX:I,pointerY:E}){l.forEach(p=>{const w=p.rect();if(ft({x:I,y:E},w)){if(r.id()===p.itemId())return;o.config().swapMode==="hover"&&r.setContinuousDrag(!0);const A=r.slot(),x=p.item();if(!o.eventHandlers().onBeforeSwap({fromSlot:A.id(),toSlot:p.id(),draggingItem:r.id(),swapWithItem:(x==null?void 0:x.id())||""}))return;if(o.config().manualSwap){const T=structuredClone(o.slotItemMap());o.swapItems(r,p);const M=o.slotItemMap(),b=tt(r.view());b.readInitial();const H=x?tt(x.view()):null;H==null||H.readInitial();let _=0,P=0;const $=J(r.view().el());$ instanceof Window?(_=$.scrollY,P=$.scrollX):(_=$.scrollTop,P=$.scrollLeft),o.eventHandlers().onSwap({oldSlotItemMap:T,newSlotItemMap:M,fromSlot:A.id(),toSlot:p.id(),draggingItem:r.id(),swappedWithItem:(x==null?void 0:x.id())||""}),requestAnimationFrame(()=>{const q=t.querySelectorAll("[data-swapy-item]");o.items().forEach(y=>{const B=Array.from(q).find(C=>C.dataset.swapyItem===y.id());y.view().updateElement(B)}),o.syncSlotItemMap(),b.readFinalAndReverse(),H==null||H.readFinalAndReverse(),et(r,b),x&&H&&et(x,H),$.scrollTo({left:P,top:_})})}else{let T=0,M=0;const b=J(r.view().el());b instanceof Window?(T=b.scrollY,M=b.scrollX):(T=b.scrollTop,M=b.scrollLeft),ht(r,p,!0),x&&ht(x,A),b.scrollTo({left:M,top:T});const H=o.slotItemMap();o.syncSlotItemMap();const _=o.slotItemMap();o.eventHandlers().onSwap({oldSlotItemMap:H,newSlotItemMap:_,fromSlot:A.id(),toSlot:p.id(),draggingItem:r.id(),swappedWithItem:(x==null?void 0:x.id())||""})}}})}function a(){t.querySelectorAll("img").forEach(r=>{r.style.pointerEvents="none"}),t.style.userSelect="none",t.style.webkitUserSelect="none"}function h(){t.querySelectorAll("img").forEach(r=>{r.style.pointerEvents=""}),t.style.userSelect="",t.style.webkitUserSelect=""}function c(r){o.config().enabled=r}function s(r){o.eventHandlers().onSwapStart=r}function f(r){o.eventHandlers().onSwap=r}function m(r){o.eventHandlers().onSwapEnd=r}function v(r){o.eventHandlers().onBeforeSwap=r}function g(){X(),requestAnimationFrame(()=>{d()})}function X(){i.forEach(r=>r.destroy()),l.forEach(r=>r.destroy()),o.destroy(),i=[],l=[]}return{enable:c,slotItemMap:()=>o.slotItemMap(),onSwapStart:s,onSwap:f,onSwapEnd:m,onBeforeSwap:v,update:g,destroy:X}}function Pt({slots:t,items:e,config:n}){const o={slots:t,items:e,config:n,slotItemMap:{asObject:{},asMap:new Map,asArray:[]},zIndexCount:1,eventHandlers:{onSwapStart:()=>{},onSwap:()=>{},onSwapEnd:()=>{},onBeforeSwap:()=>!0},scrollOffsetWhileDragging:{x:0,y:0},scrollHandler:null};let l={...o};const i=s=>{var f;(f=l.scrollHandler)==null||f.call(l,s)};window.addEventListener("scroll",i);function d(s){return l.slots.find(f=>f.id()===s)}function u(s){return l.items.find(f=>f.id()===s)}function a(){const s={},f=new Map,m=[];l.slots.forEach(v=>{var r;const g=v.id(),X=((r=v.item())==null?void 0:r.id())||"";s[g]=X,f.set(g,X),m.push({slot:g,item:X})}),l.slotItemMap={asObject:s,asMap:f,asArray:m}}function h(s,f){var p;const m=l.slotItemMap,v=s.id(),g=((p=f.item())==null?void 0:p.id())||"",X=f.id(),r=s.slot().id();m.asObject[X]=v,m.asObject[r]=g,m.asMap.set(X,v),m.asMap.set(r,g);const I=m.asArray.findIndex(w=>w.slot===X),E=m.asArray.findIndex(w=>w.slot===r);m.asArray[I].item=v,m.asArray[E].item=g}function c(){window.removeEventListener("scroll",i),l={...o}}return{slots:()=>l.slots,items:()=>l.items,config:()=>n,setItems:s=>l.items=s,setSlots:s=>l.slots=s,slotById:d,itemById:u,zIndex:(s=!1)=>s?++l.zIndexCount:l.zIndexCount,resetZIndex:()=>{l.zIndexCount=1},eventHandlers:()=>l.eventHandlers,syncSlotItemMap:a,slotItemMap:(s=!1)=>s?structuredClone(l.slotItemMap):l.slotItemMap,onScroll:s=>{l.scrollHandler=s},swapItems:h,destroy:c}}function Nt(t,e){const n=dt(t);function o(){return n.el().dataset.swapySlot}function l(){const c=n.el().children[0];return(c==null?void 0:c.dataset.swapyItem)||null}function i(){return G(n.el().getBoundingClientRect())}function d(){const c=n.el().children[0];if(c)return e.itemById(c.dataset.swapyItem)}function u(){e.slots().forEach(c=>{c.view().el().removeAttribute("data-swapy-highlighted")})}function a(){u(),n.el().setAttribute("data-swapy-highlighted","")}function h(){}return{id:o,view:()=>n,itemId:l,rect:i,item:d,highlight:a,unhighlightAllSlots:u,isHighlighted:()=>n.el().hasAttribute("data-swapy-highlighted"),destroy:h}}function qt(t,e){const n=dt(t),o={};let l=null,i=null,d=!1,u=!0,a;const h=Ft();let c=()=>{},s=()=>{},f=()=>{},m=()=>{};const{onDrag:v,onDrop:g,onHold:X,onRelease:r}=n.usePlugin(Mt,{startDelay:e.config().dragOnHold?400:0,targetEl:P()}),I=R(0,0),E=R(0,0),p=R(0,0),w=R(0,0);let A=null,x=null;X(S=>{e.config().enabled&&(q()&&!$(S.el)||C()&&B(S.el)||f==null||f(S))}),r(S=>{e.config().enabled&&(q()&&!$(S.el)||C()&&B(S.el)||m==null||m(S))});function T(S){var F;V(),ot().highlight(),(F=o.drop)==null||F.call(o);const Y=e.slots().map(O=>O.view().boundingRect());e.slots().forEach((O,z)=>{const U=Y[z];O.view().el().style.width=`${U.width}px`,O.view().el().style.maxWidth=`${U.width}px`,O.view().el().style.flexShrink="0",O.view().el().style.height=`${U.height}px`});const D=e.slotItemMap(!0);e.eventHandlers().onSwapStart({draggingItem:mt(),fromSlot:wt(),slotItemMap:D}),i=D,n.el().style.position="relative",n.el().style.zIndex=`${e.zIndex(!0)}`,A=J(S.el),e.config().autoScrollOnDrag&&(l=kt(A,e.config().dragAxis),l.updatePointer({x:S.pointerX,y:S.pointerY})),I.x=window.scrollX,I.y=window.scrollY,p.x=0,p.y=0,A instanceof HTMLElement&&(E.x=A.scrollLeft,E.y=A.scrollTop,x=()=>{w.x=A.scrollLeft-E.x,w.y=A.scrollTop-E.y,n.setTransform({dragX:((a==null?void 0:a.width)||0)+p.x+w.x,dragY:((a==null?void 0:a.height)||0)+p.y+w.y})},A.addEventListener("scroll",x)),e.onScroll(()=>{p.x=window.scrollX-I.x,p.y=window.scrollY-I.y;const O=w.x||0,z=w.y||0;n.setTransform({dragX:((a==null?void 0:a.width)||0)+p.x+O,dragY:((a==null?void 0:a.height)||0)+p.y+z})})}v(S=>{var Y;if(e.config().enabled){if(!d){if(q()&&!$(S.el)||C()&&B(S.el))return;T(S)}d=!0,l&&l.updatePointer({x:S.pointerX,y:S.pointerY}),a=S,(Y=o.drop)==null||Y.call(o),h(()=>{n.el().style.position="relative";const D=S.width+p.x+w.x,F=S.height+p.y+w.y;e.config().dragAxis==="y"?n.setTransform({dragY:F}):e.config().dragAxis==="x"?n.setTransform({dragX:D}):n.setTransform({dragX:D,dragY:F}),c==null||c(S)})}}),g(S=>{if(!d)return;nt(),d=!1,u=!1,a=null,A&&(A.removeEventListener("scroll",x),x=null),A=null,w.x=0,w.y=0,p.x=0,p.y=0,l&&(l.destroy(),l=null),ot().unhighlightAllSlots(),s==null||s(S),e.eventHandlers().onSwapEnd({slotItemMap:e.slotItemMap(),hasChanged:i!=null&&i.asMap?!Wt(i==null?void 0:i.asMap,e.slotItemMap().asMap):!1}),i=null,e.onScroll(null),e.slots().forEach(D=>{D.view().el().style.width="",D.view().el().style.maxWidth="",D.view().el().style.flexShrink="",D.view().el().style.height=""}),e.config().manualSwap&&e.config().swapMode==="drop"?requestAnimationFrame(Y):Y();function Y(){const D=n.currentTransform(),F=D.dragX+D.translateX,O=D.dragY+D.translateY;o.drop=ct({translate:R(F,O)},{translate:R(0,0)},({translate:z},U)=>{U?d||(n.clearTransform(),n.el().style.transformOrigin=""):n.setTransform({dragX:0,dragY:0,translateX:z.x,translateY:z.y}),U&&(e.items().forEach(St=>{St.isDragging()||(St.view().el().style.zIndex="")}),e.resetZIndex(),n.el().style.position="",u=!0)},gt(e.config().animation))}});function M(S){c=S}function b(S){s=S}function H(S){f=S}function _(S){m=S}function P(){return n.el().querySelector("[data-swapy-handle]")}function $(S){const Y=P();return Y?Y===S||Y.contains(S):!1}function q(){return P()!==null}function y(){return Array.from(n.el().querySelectorAll("[data-swapy-no-drag]"))}function B(S){const Y=y();return!Y||Y.length===0?!1:Y.includes(S)||Y.some(D=>D.contains(S))}function C(){return y().length>0}function V(){n.el().setAttribute("data-swapy-dragging","")}function nt(){n.el().removeAttribute("data-swapy-dragging")}function Vt(){c=null,s=null,f=null,m=null,a=null,i=null,l&&(l.destroy(),l=null),A&&x&&A.removeEventListener("scroll",x),n.destroy()}function mt(){return n.el().dataset.swapyItem}function ot(){return e.slotById(n.el().parentElement.dataset.swapySlot)}function wt(){return n.el().parentElement.dataset.swapySlot}return{id:mt,view:()=>n,slot:ot,slotId:wt,onDrag:M,onDrop:b,onHold:H,onRelease:_,destroy:Vt,isDragging:()=>d,cancelAnimation:()=>o,dragEvent:()=>a,store:()=>e,continuousDrag:()=>u,setContinuousDrag:S=>u=S}}function ht(t,e,n=!1){if(n){const l=e.item();l&&(e.view().el().style.position="relative",l.view().el().style.position="absolute")}else{const l=t.slot();l.view().el().style.position="",t.view().el().style.position=""}if(!t)return;const o=tt(t.view());o.readInitial(),e.view().el().appendChild(t.view().el()),o.readFinalAndReverse(),et(t,o)}function Ft(){let t=!1;return e=>{t||(t=!0,requestAnimationFrame(()=>{e(),t=!1}))}}function et(t,e){var u,a,h,c;(a=(u=t.cancelAnimation()).moveToSlot)==null||a.call(u),(c=(h=t.cancelAnimation()).drop)==null||c.call(h);const n=gt(t.store().config().animation),o=e.transitionValues();let l=t.view().currentTransform(),i=0,d=!1;t.cancelAnimation().moveToSlot=ct({translate:o.from.translate,scale:o.from.scale,borderRadius:o.from.borderRadius},{translate:o.to.translate,scale:o.to.scale,borderRadius:o.to.borderRadius},({translate:s,scale:f,borderRadius:m},v,g)=>{if(t.isDragging()){i!==0&&(d=!0);const r=t.dragEvent().relativeX,I=t.dragEvent().relativeY;t.continuousDrag()?t.view().setTransform({translateX:L(l.translateX,l.translateX+(o.from.width-o.to.width)*r,n.easing(g-i)),translateY:L(l.translateY,l.translateY+(o.from.height-o.to.height)*I,n.easing(g-i)),scaleX:f.x,scaleY:f.y}):t.view().setTransform({scaleX:f.x,scaleY:f.y})}else l=t.view().currentTransform(),i=g,d?t.view().setTransform({scaleX:f.x,scaleY:f.y}):t.view().setTransform({dragX:0,dragY:0,translateX:s.x,translateY:s.y,scaleX:f.x,scaleY:f.y});const X=e.childrenTransitionData();X.forEach(({el:r,fromTranslate:I,fromScale:E,fromBorderRadius:p,toBorderRadius:w,parentScale:A})=>{const x=L(A.x,1,n.easing(g)),T=L(A.y,1,n.easing(g));r.style.transform=`translate(${I.x+(0-I.x/x)*n.easing(g)}px, ${I.y+(0-I.y/T)*n.easing(g)}px) scale(${L(E.x/x,1/x,n.easing(g))}, ${L(E.y/T,1/T,n.easing(g))})`,it(p)||(r.style.borderRadius=Z(st(p,w,n.easing(g))))}),it(m)||(t.view().el().style.borderRadius=Z(m)),v&&(t.isDragging()||(t.view().el().style.transformOrigin="",t.view().clearTransform()),t.view().el().style.borderRadius="",X.forEach(({el:r})=>{r.style.transform="",r.style.transformOrigin="",r.style.borderRadius=""}))},n)}function k(...t){console.error("Swapy Error:",...t)}function jt(t){const e=t;let n=!0;const o=e.querySelectorAll("[data-swapy-slot]");e||(k("container passed to createSwapy() is undefined or null"),n=!1),o.forEach(u=>{const a=u,h=a.dataset.swapySlot,c=a.children,s=c[0];(!h||h.length===0)&&(k(a,"does not contain a slotId using data-swapy-slot"),n=!1),c.length>1&&(k("slot:",`"${h}"`,"cannot contain more than one element"),n=!1),s&&(!s.dataset.swapyItem||s.dataset.swapyItem.length===0)&&(k("slot",`"${h}"`,"does not contain an element with an item id using data-swapy-item"),n=!1)});const l=Array.from(o).map(u=>u.dataset.swapySlot),i=e.querySelectorAll("[data-swapy-item]"),d=Array.from(i).map(u=>u.dataset.swapyItem);if(pt(l)){const u=yt(l);k("your container has duplicate slot ids",`(${u.join(", ")})`),n=!1}if(pt(d)){const u=yt(d);k("your container has duplicate item ids",`(${u.join(", ")})`),n=!1}return n}function pt(t){return new Set(t).size!==t.length}function yt(t){const e=new Set,n=new Set;for(const o of t)e.has(o)?n.add(o):e.add(o);return Array.from(n)}function Wt(t,e){if(t.size!==e.size)return!1;for(const[n,o]of t)if(e.get(n)!==o)return!1;return!0}function J(t){let e=t;for(;e;){const n=window.getComputedStyle(e),o=n.overflowY,l=n.overflowX;if((o==="auto"||o==="scroll")&&e.scrollHeight>e.clientHeight||(l==="auto"||l==="scroll")&&e.scrollWidth>e.clientWidth)return e;e=e.parentElement}return window}function kt(t,e){let l=!1,i,d=0,u=0,a=0,h=0,c=0,s=0,f=null;t instanceof HTMLElement?(i=G(t.getBoundingClientRect()),d=t.scrollHeight-i.height,u=t.scrollWidth-i.width):(i={x:0,y:0,width:window.innerWidth,height:window.innerHeight},d=document.documentElement.scrollHeight-window.innerHeight,u=document.documentElement.scrollWidth-window.innerWidth);function m(){t instanceof HTMLElement?(a=t.scrollTop,h=t.scrollLeft):(a=window.scrollY,h=window.scrollX)}function v(r){l=!1;const I=i.y,E=i.y+i.height,p=i.x,w=i.x+i.width,A=Math.abs(I-r.y)<Math.abs(E-r.y),x=Math.abs(p-r.x)<Math.abs(w-r.x);if(m(),e!=="x")if(A){const T=I-r.y;if(T>=-100){const M=W(T,-100,0);c=-K(-100,0,0,5,M),l=!0}}else{const T=E-r.y;if(T<=100){const M=W(T,0,100);c=K(100,0,0,5,M),l=!0}}if(e!=="y")if(x){const T=p-r.x;if(T>=-100){const M=W(T,-100,0);s=-K(-100,0,0,5,M),l=!0}}else{const T=w-r.x;if(T<=100){const M=W(T,0,100);s=K(100,0,0,5,M),l=!0}}l&&(f&&cancelAnimationFrame(f),g())}function g(){m(),e!=="x"&&(c=a+c>=d?0:c),e!=="y"&&(s=h+s>=u?0:s),t.scrollBy({top:c,left:s}),l&&(f=requestAnimationFrame(g))}function X(){l=!1}return{updatePointer:v,destroy:X}}N.createSwapy=_t,N.getClosestScrollableContainer=J,N.utils=Bt,Object.defineProperty(N,Symbol.toStringTag,{value:"Module"})});
+  `}function at(t){return t.x.topLeft===0&&t.x.topRight===0&&t.x.bottomRight===0&&t.x.bottomLeft===0&&t.y.topLeft===0&&t.y.topRight===0&&t.y.bottomRight===0&&t.y.bottomLeft===0}function st(t){return typeof t=="object"&&"x"in t&&"y"in t}function R(t,e){return{x:t,y:e}}function vt(t,e){return R(t.x+e.x,t.y+e.y)}function At(t,e){return R(t.x-e.x,t.y-e.y)}function Et(t,e){return R(t.x*e,t.y*e)}function C(t,e,n){return t+(e-t)*n}function It(t,e,n){return vt(t,Et(At(e,t),n))}function ct(t,e,n){return{x:{topLeft:C(t.x.topLeft,e.x.topLeft,n),topRight:C(t.x.topRight,e.x.topRight,n),bottomRight:C(t.x.bottomRight,e.x.bottomRight,n),bottomLeft:C(t.x.bottomLeft,e.x.bottomLeft,n)},y:{topLeft:C(t.y.topLeft,e.y.topLeft,n),topRight:C(t.y.topRight,e.y.topRight,n),bottomRight:C(t.y.bottomRight,e.y.bottomRight,n),bottomLeft:C(t.y.bottomLeft,e.y.bottomLeft,n)},unit:t.unit}}function Tt(t,e,n){return k((n-t)/(e-t),0,1)}function J(t,e,n,o,l){return C(n,o,Tt(t,e,l))}function k(t,e,n){return Math.min(Math.max(t,e),n)}const Xt={duration:350,easing:t=>t};function ft(t,e,n,o){let l=!1;const i=()=>{l=!0},d={...Xt,...o};let c;function a(h){c===void 0&&(c=h);const f=h-c,s=k(f/d.duration,0,1),u=Object.keys(t),m=Object.keys(e);if(!u.every(g=>m.includes(g))){console.error("animate Error: `from` keys are different than `to`");return}const x={};u.forEach(g=>{typeof t[g]=="number"&&typeof e[g]=="number"?x[g]=C(t[g],e[g],d.easing(s)):W(t[g])&&W(e[g])?x[g]=ct(t[g],e[g],d.easing(s)):st(t[g])&&st(e[g])&&(x[g]=It(t[g],e[g],d.easing(s)))}),n(x,s>=1,s),s<1&&!l&&requestAnimationFrame(a)}return requestAnimationFrame(a),i}const Mt={startDelay:0,targetEl:null};function bt(t,e){const n={...Mt,...e};let o=t.el(),l=!1,i=null,d=null,c=null,a=null,h=0,f=0,s=0,u=0,m=0,x=0,g=0,X=0,r=0,E=0,I=null,p=null,w;o.addEventListener("pointerdown",A),document.body.addEventListener("pointerup",T),document.body.addEventListener("pointermove",M),document.body.addEventListener("touchmove",b,{passive:!1});function A(y){if(n.targetEl&&y.target!==n.targetEl&&!n.targetEl.contains(y.target)||l||!y.isPrimary)return;if(n.startDelay>0){c==null||c({el:y.target}),p=null;let D=y.target;for(;D&&p==null;){if(D.hasAttribute("data-swapy-item")){p=D;break}D=D.parentElement}w=setTimeout(()=>{B()},n.startDelay)}else B();function B(){I=y.target;const D=t.boundingRect(),z=t.layoutRect();m=z.x,x=z.y,s=D.x-m,u=D.y-x,h=y.clientX-s,f=y.clientY-u,g=y.clientX,X=y.clientY,r=(y.clientX-D.x)/D.width,E=(y.clientY-D.y)/D.height,l=!0,M(y)}}function v(){const y=t.layoutRect();h-=m-y.x,f-=x-y.y,m=y.x,x=y.y}function T(y){if(!l){w&&(clearTimeout(w),p=null,w=null,a==null||a({el:y.target}));return}if(!y.isPrimary)return;l=!1;const B=y.clientX-g,D=y.clientY-X;d==null||d({x:s,y:u,pointerX:y.clientX,pointerY:y.clientY,width:B,height:D,relativeX:r,relativeY:E,el:I}),I=null}function M(y){if(!l){if(p&&(p===y.target||p.contains(y.target)))return;w&&(clearTimeout(w),c=null,w=null,a==null||a({el:y.target}));return}if(!y.isPrimary)return;const B=y.clientX-g,D=y.clientY-X,z=s=y.clientX-h,ot=u=y.clientY-f;i==null||i({width:B,height:D,x:z,y:ot,pointerX:y.clientX,pointerY:y.clientY,relativeX:r,relativeY:E,el:I})}function b(y){if(!l)return!0;y.preventDefault()}function H(y){i=y}function _(y){d=y}function P(y){c=y}function $(y){a=y}function q(){o.removeEventListener("pointerdown",A),o=t.el(),o.addEventListener("pointerdown",A)}function F(){t.el().removeEventListener("pointerdown",A),document.body.removeEventListener("pointerup",T),document.body.removeEventListener("pointermove",M),document.body.removeEventListener("touchmove",b),i=null,d=null,c=null,a=null}return{onDrag:H,onDrop:_,onHold:P,onRelease:$,onElementUpdate:q,destroy:F,readjust:v}}function Dt(t){return 1+2.70158*Math.pow(t-1,3)+1.70158*Math.pow(t-1,2)}function Lt(t){return 1-Math.pow(1-t,3)}function Z(t){return{x:t.x,y:t.y,width:t.width,height:t.height}}function Ct(t){const e=t.getBoundingClientRect();let n=0,o=0,l=t.parentElement;for(;l;){const d=getComputedStyle(l).transform;if(d&&d!=="none"){const c=d.match(/matrix.*\((.+)\)/);if(c){const a=c[1].split(", ").map(Number);n+=a[4]||0,o+=a[5]||0}}l=l.parentElement}return{y:e.top-o,x:e.left-n,width:e.width,height:e.height}}function tt(t){let e=t,n=0,o=0;for(;e;)n+=e.offsetTop,o+=e.offsetLeft,e=e.offsetParent;return{x:o,y:n,width:t.offsetWidth,height:t.offsetHeight}}function ut(t,e){return t.x>=e.x&&t.x<=e.x+e.width&&t.y>=e.y&&t.y<=e.y+e.height}function Yt(t){let e=t,n=0,o=0;for(;e;){const l=i=>{const d=getComputedStyle(i);return/(auto|scroll)/.test(d.overflow+d.overflowY+d.overflowX)};if(e===document.body){o+=window.scrollX,n+=window.scrollY;break}l(e)&&(o+=e.scrollLeft,n+=e.scrollTop),e=e.parentElement}return{x:o,y:n}}function et(t){let e="unread",n,o,l,i,d,c,a,h,f,s,u;function m(){n=t.currentTransform(),o=Ct(t.el()),l=Yt(t.el()),u=dt(t.el()).map(({parent:E,children:I})=>({parent:{el:E,initialRect:Z(E.getBoundingClientRect())},children:I.filter(p=>p instanceof HTMLElement).map(p=>{const w=p;return w.originalBorderRadius||(w.originalBorderRadius=getComputedStyle(p).borderRadius),{el:p,borderRadius:rt(w.originalBorderRadius),initialRect:Z(p.getBoundingClientRect())}})})),e="readInitial"}function x(){if(e!=="readInitial")throw new Error("FlipView: Cannot read final values before reading initial values");f=t.layoutRect(),c=o.width/f.width,a=o.height/f.height,i=o.x-f.x-n.dragX+l.x,d=o.y-f.y-n.dragY+l.y,h=it(t.borderRadius(),c,a);const r=dt(t.el());u=u.map(({parent:I,children:p},w)=>{const A=r[w].parent;return{parent:{...I,el:A,finalRect:tt(A)},children:p.map((v,T)=>{const M=r[w].children[T];let b=tt(M);return M.hasAttribute("data-swapy-text")&&(b={...b,width:v.initialRect.width,height:v.initialRect.height}),{...v,el:M,finalRect:b}})}});const E={translateX:i,translateY:d,scaleX:c,scaleY:a};t.el().style.transformOrigin="0 0",t.el().style.borderRadius=K(h),t.setTransform(E),s=[],u.forEach(({parent:I,children:p})=>{const w=p.map(({el:A,initialRect:v,finalRect:T,borderRadius:M})=>Rt(A,v,T,M,I.initialRect,I.finalRect));s.push(...w)}),e="readFinal"}function g(){if(e!=="readFinal")throw new Error("FlipView: Cannot get transition values before reading");return{from:{width:o.width,height:o.height,translate:R(i,d),scale:R(c,a),borderRadius:h},to:{width:f.width,height:f.height,translate:R(0,0),scale:R(1,1),borderRadius:t.borderRadius()}}}function X(){if(e!=="readFinal")throw new Error("FlipView: Cannot get children transition values before reading");return s}return{readInitial:m,readFinalAndReverse:x,transitionValues:g,childrenTransitionData:X}}function Rt(t,e,n,o,l,i){t.style.transformOrigin="0 0";const d=l.width/i.width,c=l.height/i.height,a=e.width/n.width,h=e.height/n.height,f=it(o,a,h),s=e.x-l.x,u=n.x-i.x,m=e.y-l.y,x=n.y-i.y,g=(s-u*d)/d,X=(m-x*c)/c;return t.style.transform=`translate(${g}px, ${X}px) scale(${a/d}, ${h/c})`,t.style.borderRadius=K(f),{el:t,fromTranslate:R(g,X),fromScale:R(a,h),fromBorderRadius:f,toBorderRadius:o,parentScale:{x:d,y:c}}}function dt(t){const e=[];function n(o){const l=Array.from(o.children).filter(i=>i instanceof HTMLElement);l.length>0&&(e.push({parent:o,children:l}),l.forEach(i=>n(i)))}return n(t),e}function gt(t){const e=[];let n=t,o={dragX:0,dragY:0,translateX:0,translateY:0,scaleX:1,scaleY:1};const l=rt(window.getComputedStyle(n).borderRadius),i={el:()=>n,setTransform:d,clearTransform:c,currentTransform:()=>o,borderRadius:()=>l,layoutRect:()=>tt(n),boundingRect:()=>Z(n.getBoundingClientRect()),usePlugin:h,destroy:f,updateElement:s};function d(u){o={...o,...u},a()}function c(){o={dragX:0,dragY:0,translateX:0,translateY:0,scaleX:1,scaleY:1},a()}function a(){const{dragX:u,dragY:m,translateX:x,translateY:g,scaleX:X,scaleY:r}=o;u===0&&m===0&&x===0&&g===0&&X===1&&r===1?n.style.transform="":n.style.transform=`translate(${u+x}px, ${m+g}px) scale(${X}, ${r})`}function h(u,m){const x=u(i,m);return e.push(x),x}function f(){e.forEach(u=>u.destroy())}function s(u){if(!u)return;const m=n.hasAttribute("data-swapy-dragging"),x=n.style.cssText;n=u,m&&n.setAttribute("data-swapy-dragging",""),n.style.cssText=x,e.forEach(g=>g.onElementUpdate())}return i}function Ht(t,e,n){return n.map(o=>({slotId:o.slot,itemId:o.item,item:o.item===""?null:t.find(l=>o.item===l[e])}))}function $t(t,e){return t.map(n=>({item:n[e],slot:n[e]}))}function Bt(t,e,n,o,l,i=!1){const d=e.filter(h=>!o.some(f=>f.item===h[n])).map(h=>({slot:h[n],item:h[n]}));let c;i?c=o.map(h=>e.some(f=>f[n]===h.item)?h:{slot:h.slot,item:""}):c=o.filter(h=>e.some(f=>f[n]===h.item)||!h.item);const a=[...c,...d];l(a),(d.length>0||c.length!==o.length)&&requestAnimationFrame(()=>{t==null||t.update()})}const Ot=Object.freeze(Object.defineProperty({__proto__:null,dynamicSwapy:Bt,initSlotItemMap:$t,toSlottedItems:Ht},Symbol.toStringTag,{value:"Module"})),_t={animation:"dynamic",enabled:!0,swapMode:"hover",dragOnHold:!1,autoScrollOnDrag:!1,dragAxis:"both",manualSwap:!1};function ht(t){switch(t){case"dynamic":return{easing:Lt,duration:300};case"spring":return{easing:Dt,duration:350};case"none":return{easing:e=>e,duration:1}}}function Pt(t,e){const n={..._t,...e},o=Nt({slots:[],items:[],config:n});let l=[],i=[];d();function d(){if(!Wt(t))throw new Error("Cannot create a Swapy instance because your HTML structure is invalid. Fix all above errors and then try!");l=Array.from(t.querySelectorAll("[data-swapy-slot]")).map(r=>qt(r,o)),o.setSlots(l),i=Array.from(t.querySelectorAll("[data-swapy-item]")).map(r=>Ft(r,o)),o.setItems(i),o.syncSlotItemMap(),i.forEach(r=>{r.onDrag(({pointerX:E,pointerY:I})=>{a();let p=!1;l.forEach(w=>{const A=w.rect();ut({x:E,y:I},A)&&(p=!0,w.isHighlighted()||w.highlight())}),!p&&o.config().swapMode==="drop"&&r.slot().highlight(),n.swapMode==="hover"&&c(r,{pointerX:E,pointerY:I})}),r.onDrop(({pointerX:E,pointerY:I})=>{h(),n.swapMode==="drop"&&c(r,{pointerX:E,pointerY:I})}),r.onHold(()=>{a()}),r.onRelease(()=>{h()})})}function c(r,{pointerX:E,pointerY:I}){l.forEach(p=>{const w=p.rect();if(ut({x:E,y:I},w)){if(r.id()===p.itemId())return;o.config().swapMode==="hover"&&r.setContinuousDrag(!0);const A=r.slot(),v=p.item();if(!o.eventHandlers().onBeforeSwap({fromSlot:A.id(),toSlot:p.id(),draggingItem:r.id(),swapWithItem:(v==null?void 0:v.id())||""}))return;if(o.config().manualSwap){const T=structuredClone(o.slotItemMap());o.swapItems(r,p);const M=o.slotItemMap(),b=et(r.view());b.readInitial();const H=v?et(v.view()):null;H==null||H.readInitial();let _=0,P=0;const $=Q(r.view().el());$ instanceof Window?(_=$.scrollY,P=$.scrollX):(_=$.scrollTop,P=$.scrollLeft),o.eventHandlers().onSwap({oldSlotItemMap:T,newSlotItemMap:M,fromSlot:A.id(),toSlot:p.id(),draggingItem:r.id(),swappedWithItem:(v==null?void 0:v.id())||""}),requestAnimationFrame(()=>{const q=t.querySelectorAll("[data-swapy-item]");o.items().forEach(F=>{const y=Array.from(q).find(B=>B.dataset.swapyItem===F.id());F.view().updateElement(y)}),o.syncSlotItemMap(),b.readFinalAndReverse(),H==null||H.readFinalAndReverse(),nt(r,b),v&&H&&nt(v,H),$.scrollTo({left:P,top:_})})}else{let T=0,M=0;const b=Q(r.view().el());b instanceof Window?(T=b.scrollY,M=b.scrollX):(T=b.scrollTop,M=b.scrollLeft),pt(r,p,!0),v&&pt(v,A),b.scrollTo({left:M,top:T});const H=o.slotItemMap();o.syncSlotItemMap();const _=o.slotItemMap();o.eventHandlers().onSwap({oldSlotItemMap:H,newSlotItemMap:_,fromSlot:A.id(),toSlot:p.id(),draggingItem:r.id(),swappedWithItem:(v==null?void 0:v.id())||""})}}})}function a(){t.querySelectorAll("img").forEach(r=>{r.style.pointerEvents="none"}),t.style.userSelect="none",t.style.webkitUserSelect="none"}function h(){t.querySelectorAll("img").forEach(r=>{r.style.pointerEvents=""}),t.style.userSelect="",t.style.webkitUserSelect=""}function f(r){o.config().enabled=r}function s(r){o.eventHandlers().onSwapStart=r}function u(r){o.eventHandlers().onSwap=r}function m(r){o.eventHandlers().onSwapEnd=r}function x(r){o.eventHandlers().onBeforeSwap=r}function g(){X(),requestAnimationFrame(()=>{d()})}function X(){i.forEach(r=>r.destroy()),l.forEach(r=>r.destroy()),o.destroy(),i=[],l=[]}return{enable:f,slotItemMap:()=>o.slotItemMap(),onSwapStart:s,onSwap:u,onSwapEnd:m,onBeforeSwap:x,update:g,destroy:X}}function Nt({slots:t,items:e,config:n}){const o={slots:t,items:e,config:n,slotItemMap:{asObject:{},asMap:new Map,asArray:[]},zIndexCount:1,eventHandlers:{onSwapStart:()=>{},onSwap:()=>{},onSwapEnd:()=>{},onBeforeSwap:()=>!0},scrollOffsetWhileDragging:{x:0,y:0},scrollHandler:null};let l={...o};const i=s=>{var u;(u=l.scrollHandler)==null||u.call(l,s)};window.addEventListener("scroll",i);function d(s){return l.slots.find(u=>u.id()===s)}function c(s){return l.items.find(u=>u.id()===s)}function a(){const s={},u=new Map,m=[];l.slots.forEach(x=>{var r;const g=x.id(),X=((r=x.item())==null?void 0:r.id())||"";s[g]=X,u.set(g,X),m.push({slot:g,item:X})}),l.slotItemMap={asObject:s,asMap:u,asArray:m}}function h(s,u){var p;const m=l.slotItemMap,x=s.id(),g=((p=u.item())==null?void 0:p.id())||"",X=u.id(),r=s.slot().id();m.asObject[X]=x,m.asObject[r]=g,m.asMap.set(X,x),m.asMap.set(r,g);const E=m.asArray.findIndex(w=>w.slot===X),I=m.asArray.findIndex(w=>w.slot===r);m.asArray[E].item=x,m.asArray[I].item=g}function f(){window.removeEventListener("scroll",i),l={...o}}return{slots:()=>l.slots,items:()=>l.items,config:()=>n,setItems:s=>l.items=s,setSlots:s=>l.slots=s,slotById:d,itemById:c,zIndex:(s=!1)=>s?++l.zIndexCount:l.zIndexCount,resetZIndex:()=>{l.zIndexCount=1},eventHandlers:()=>l.eventHandlers,syncSlotItemMap:a,slotItemMap:(s=!1)=>s?structuredClone(l.slotItemMap):l.slotItemMap,onScroll:s=>{l.scrollHandler=s},swapItems:h,destroy:f}}function qt(t,e){const n=gt(t);function o(){return n.el().dataset.swapySlot}function l(){const f=n.el().children[0];return(f==null?void 0:f.dataset.swapyItem)||null}function i(){return Z(n.el().getBoundingClientRect())}function d(){const f=n.el().children[0];if(f)return e.itemById(f.dataset.swapyItem)}function c(){e.slots().forEach(f=>{f.view().el().removeAttribute("data-swapy-highlighted")})}function a(){c(),n.el().setAttribute("data-swapy-highlighted","")}function h(){}return{id:o,view:()=>n,itemId:l,rect:i,item:d,highlight:a,unhighlightAllSlots:c,isHighlighted:()=>n.el().hasAttribute("data-swapy-highlighted"),destroy:h}}function Ft(t,e){const n=gt(t),o={};let l=null,i=null,d=!1,c=!0,a;const h=jt();let f=()=>{},s=()=>{},u=()=>{},m=()=>{};const{onDrag:x,onDrop:g,onHold:X,onRelease:r}=n.usePlugin(bt,{startDelay:e.config().dragOnHold?400:0,targetEl:P()}),E=R(0,0),I=R(0,0),p=R(0,0),w=R(0,0);let A=null,v=null;X(S=>{e.config().enabled&&(q()&&!$(S.el)||B()&&y(S.el)||u==null||u(S))}),r(S=>{e.config().enabled&&(q()&&!$(S.el)||B()&&y(S.el)||m==null||m(S))});function T(S){var j;D(),lt().highlight(),(j=o.drop)==null||j.call(o);const Y=e.slots().map(O=>O.view().boundingRect());e.slots().forEach((O,U)=>{const G=Y[U];O.view().el().style.width=`${G.width}px`,O.view().el().style.maxWidth=`${G.width}px`,O.view().el().style.flexShrink="0",O.view().el().style.height=`${G.height}px`});const L=e.slotItemMap(!0);e.eventHandlers().onSwapStart({draggingItem:wt(),fromSlot:St(),slotItemMap:L}),i=L,n.el().style.position="relative",n.el().style.zIndex=`${e.zIndex(!0)}`,A=Q(S.el),e.config().autoScrollOnDrag&&(l=Vt(A,e.config().dragAxis),l.updatePointer({x:S.pointerX,y:S.pointerY})),E.x=window.scrollX,E.y=window.scrollY,p.x=0,p.y=0,A instanceof HTMLElement&&(I.x=A.scrollLeft,I.y=A.scrollTop,v=()=>{w.x=A.scrollLeft-I.x,w.y=A.scrollTop-I.y,n.setTransform({dragX:((a==null?void 0:a.width)||0)+p.x+w.x,dragY:((a==null?void 0:a.height)||0)+p.y+w.y})},A.addEventListener("scroll",v)),e.onScroll(()=>{p.x=window.scrollX-E.x,p.y=window.scrollY-E.y;const O=w.x||0,U=w.y||0;n.setTransform({dragX:((a==null?void 0:a.width)||0)+p.x+O,dragY:((a==null?void 0:a.height)||0)+p.y+U})})}x(S=>{var Y;if(e.config().enabled){if(!d){if(q()&&!$(S.el)||B()&&y(S.el))return;T(S)}d=!0,l&&l.updatePointer({x:S.pointerX,y:S.pointerY}),a=S,(Y=o.drop)==null||Y.call(o),h(()=>{n.el().style.position="relative";const L=S.width+p.x+w.x,j=S.height+p.y+w.y;e.config().dragAxis==="y"?n.setTransform({dragY:j}):e.config().dragAxis==="x"?n.setTransform({dragX:L}):n.setTransform({dragX:L,dragY:j}),f==null||f(S)})}}),g(S=>{if(!d)return;z(),d=!1,c=!1,a=null,A&&(A.removeEventListener("scroll",v),v=null),A=null,w.x=0,w.y=0,p.x=0,p.y=0,l&&(l.destroy(),l=null),lt().unhighlightAllSlots(),s==null||s(S),e.eventHandlers().onSwapEnd({slotItemMap:e.slotItemMap(),hasChanged:i!=null&&i.asMap?!kt(i==null?void 0:i.asMap,e.slotItemMap().asMap):!1}),i=null,e.onScroll(null),e.slots().forEach(L=>{L.view().el().style.width="",L.view().el().style.maxWidth="",L.view().el().style.flexShrink="",L.view().el().style.height=""}),e.config().manualSwap&&e.config().swapMode==="drop"?requestAnimationFrame(Y):Y();function Y(){const L=n.currentTransform(),j=L.dragX+L.translateX,O=L.dragY+L.translateY;o.drop=ft({translate:R(j,O)},{translate:R(0,0)},({translate:U},G)=>{G?d||(n.clearTransform(),n.el().style.transformOrigin=""):n.setTransform({dragX:0,dragY:0,translateX:U.x,translateY:U.y}),G&&(e.items().forEach(xt=>{xt.isDragging()||(xt.view().el().style.zIndex="")}),e.resetZIndex(),n.el().style.position="",c=!0)},ht(e.config().animation))}});function M(S){f=S}function b(S){s=S}function H(S){u=S}function _(S){m=S}function P(){return n.el().querySelector("[data-swapy-handle]")}function $(S){const Y=P();return Y?Y===S||Y.contains(S):!1}function q(){return P()!==null}function F(){return Array.from(n.el().querySelectorAll("[data-swapy-no-drag]"))}function y(S){const Y=F();return!Y||Y.length===0?!1:Y.includes(S)||Y.some(L=>L.contains(S))}function B(){return F().length>0}function D(){n.el().setAttribute("data-swapy-dragging","")}function z(){n.el().removeAttribute("data-swapy-dragging")}function ot(){f=null,s=null,u=null,m=null,a=null,i=null,l&&(l.destroy(),l=null),A&&v&&A.removeEventListener("scroll",v),n.destroy()}function wt(){return n.el().dataset.swapyItem}function lt(){return e.slotById(n.el().parentElement.dataset.swapySlot)}function St(){return n.el().parentElement.dataset.swapySlot}return{id:wt,view:()=>n,slot:lt,slotId:St,onDrag:M,onDrop:b,onHold:H,onRelease:_,destroy:ot,isDragging:()=>d,cancelAnimation:()=>o,dragEvent:()=>a,store:()=>e,continuousDrag:()=>c,setContinuousDrag:S=>c=S}}function pt(t,e,n=!1){if(n){const l=e.item();l&&(e.view().el().style.position="relative",l.view().el().style.position="absolute")}else{const l=t.slot();l.view().el().style.position="",t.view().el().style.position=""}if(!t)return;const o=et(t.view());o.readInitial(),e.view().el().appendChild(t.view().el()),o.readFinalAndReverse(),nt(t,o)}function jt(){let t=!1;return e=>{t||(t=!0,requestAnimationFrame(()=>{e(),t=!1}))}}function nt(t,e){var c,a,h,f;(a=(c=t.cancelAnimation()).moveToSlot)==null||a.call(c),(f=(h=t.cancelAnimation()).drop)==null||f.call(h);const n=ht(t.store().config().animation),o=e.transitionValues();let l=t.view().currentTransform(),i=0,d=!1;t.cancelAnimation().moveToSlot=ft({translate:o.from.translate,scale:o.from.scale,borderRadius:o.from.borderRadius},{translate:o.to.translate,scale:o.to.scale,borderRadius:o.to.borderRadius},({translate:s,scale:u,borderRadius:m},x,g)=>{if(t.isDragging()){i!==0&&(d=!0);const r=t.dragEvent().relativeX,E=t.dragEvent().relativeY;t.continuousDrag()?t.view().setTransform({translateX:C(l.translateX,l.translateX+(o.from.width-o.to.width)*r,n.easing(g-i)),translateY:C(l.translateY,l.translateY+(o.from.height-o.to.height)*E,n.easing(g-i)),scaleX:u.x,scaleY:u.y}):t.view().setTransform({scaleX:u.x,scaleY:u.y})}else l=t.view().currentTransform(),i=g,d?t.view().setTransform({scaleX:u.x,scaleY:u.y}):t.view().setTransform({dragX:0,dragY:0,translateX:s.x,translateY:s.y,scaleX:u.x,scaleY:u.y});const X=e.childrenTransitionData();X.forEach(({el:r,fromTranslate:E,fromScale:I,fromBorderRadius:p,toBorderRadius:w,parentScale:A})=>{const v=C(A.x,1,n.easing(g)),T=C(A.y,1,n.easing(g));r.style.transform=`translate(${E.x+(0-E.x/v)*n.easing(g)}px, ${E.y+(0-E.y/T)*n.easing(g)}px) scale(${C(I.x/v,1/v,n.easing(g))}, ${C(I.y/T,1/T,n.easing(g))})`,at(p)||(r.style.borderRadius=K(ct(p,w,n.easing(g))))}),at(m)||(t.view().el().style.borderRadius=K(m)),x&&(t.isDragging()||(t.view().el().style.transformOrigin="",t.view().clearTransform()),t.view().el().style.borderRadius="",X.forEach(({el:r})=>{r.style.transform="",r.style.transformOrigin="",r.style.borderRadius=""}))},n)}function V(...t){console.error("Swapy Error:",...t)}function Wt(t){const e=t;let n=!0;const o=e.querySelectorAll("[data-swapy-slot]");e||(V("container passed to createSwapy() is undefined or null"),n=!1),o.forEach(c=>{const a=c,h=a.dataset.swapySlot,f=a.children,s=f[0];(!h||h.length===0)&&(V(a,"does not contain a slotId using data-swapy-slot"),n=!1),f.length>1&&(V("slot:",`"${h}"`,"cannot contain more than one element"),n=!1),s&&(!s.dataset.swapyItem||s.dataset.swapyItem.length===0)&&(V("slot",`"${h}"`,"does not contain an element with an item id using data-swapy-item"),n=!1)});const l=Array.from(o).map(c=>c.dataset.swapySlot),i=e.querySelectorAll("[data-swapy-item]"),d=Array.from(i).map(c=>c.dataset.swapyItem);if(yt(l)){const c=mt(l);V("your container has duplicate slot ids",`(${c.join(", ")})`),n=!1}if(yt(d)){const c=mt(d);V("your container has duplicate item ids",`(${c.join(", ")})`),n=!1}return n}function yt(t){return new Set(t).size!==t.length}function mt(t){const e=new Set,n=new Set;for(const o of t)e.has(o)?n.add(o):e.add(o);return Array.from(n)}function kt(t,e){if(t.size!==e.size)return!1;for(const[n,o]of t)if(e.get(n)!==o)return!1;return!0}function Q(t){let e=t;for(;e;){const n=window.getComputedStyle(e),o=n.overflowY,l=n.overflowX;if((o==="auto"||o==="scroll")&&e.scrollHeight>e.clientHeight||(l==="auto"||l==="scroll")&&e.scrollWidth>e.clientWidth)return e;e=e.parentElement}return window}function Vt(t,e){let l=!1,i,d=0,c=0,a=0,h=0,f=0,s=0,u=null;t instanceof HTMLElement?(i=Z(t.getBoundingClientRect()),d=t.scrollHeight-i.height,c=t.scrollWidth-i.width):(i={x:0,y:0,width:window.innerWidth,height:window.innerHeight},d=document.documentElement.scrollHeight-window.innerHeight,c=document.documentElement.scrollWidth-window.innerWidth);function m(){t instanceof HTMLElement?(a=t.scrollTop,h=t.scrollLeft):(a=window.scrollY,h=window.scrollX)}function x(r){l=!1;const E=i.y,I=i.y+i.height,p=i.x,w=i.x+i.width,A=Math.abs(E-r.y)<Math.abs(I-r.y),v=Math.abs(p-r.x)<Math.abs(w-r.x);if(m(),e!=="x")if(A){const T=E-r.y;if(T>=-100){const M=k(T,-100,0);f=-J(-100,0,0,5,M),l=!0}}else{const T=I-r.y;if(T<=100){const M=k(T,0,100);f=J(100,0,0,5,M),l=!0}}if(e!=="y")if(v){const T=p-r.x;if(T>=-100){const M=k(T,-100,0);s=-J(-100,0,0,5,M),l=!0}}else{const T=w-r.x;if(T<=100){const M=k(T,0,100);s=J(100,0,0,5,M),l=!0}}l&&(u&&cancelAnimationFrame(u),g())}function g(){m(),e!=="x"&&(f=a+f>=d?0:f),e!=="y"&&(s=h+s>=c?0:s),t.scrollBy({top:f,left:s}),l&&(u=requestAnimationFrame(g))}function X(){l=!1}return{updatePointer:x,destroy:X}}N.createSwapy=Pt,N.getClosestScrollableContainer=Q,N.utils=Ot,Object.defineProperty(N,Symbol.toStringTag,{value:"Module"})});
